(this["webpackJsonp"] = this["webpackJsonp"] || []).push([[27],{

/***/ "./node_modules/echarts/lib/component/dataZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n__webpack_require__(/*! ./dataZoom/typeDefaulter */ \"./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\");\n\n__webpack_require__(/*! ./dataZoom/DataZoomModel */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\");\n\n__webpack_require__(/*! ./dataZoom/DataZoomView */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\");\n\n__webpack_require__(/*! ./dataZoom/SliderZoomModel */ \"./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\");\n\n__webpack_require__(/*! ./dataZoom/SliderZoomView */ \"./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\");\n\n__webpack_require__(/*! ./dataZoom/InsideZoomModel */ \"./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\");\n\n__webpack_require__(/*! ./dataZoom/InsideZoomView */ \"./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\");\n\n__webpack_require__(/*! ./dataZoom/dataZoomProcessor */ \"./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\");\n\n__webpack_require__(/*! ./dataZoom/dataZoomAction */ \"./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS5qcz8wYTZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS90eXBlRGVmYXVsdGVyXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9EYXRhWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL1NsaWRlclpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vU2xpZGVyWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0luc2lkZVpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vSW5zaWRlWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvblwiKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/AxisProxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar numberUtil = __webpack_require__(/*! ../../util/number */ \"./node_modules/echarts/lib/util/number.js\");\n\nvar helper = __webpack_require__(/*! ./helper */ \"./node_modules/echarts/lib/component/dataZoom/helper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzP2NjMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBhc2MgPSBudW1iZXJVdGlsLmFzYztcbi8qKlxuICogT3BlcmF0ZSBzaW5nbGUgYXhpcy5cbiAqIE9uZSBheGlzIGNhbiBvbmx5IG9wZXJhdGVkIGJ5IG9uZSBheGlzIG9wZXJhdG9yLlxuICogRGlmZmVyZW50IGRhdGFab29tTW9kZWxzIG1heSBiZSBkZWZpbmVkIHRvIG9wZXJhdGUgdGhlIHNhbWUgYXhpcy5cbiAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpXG4gKiBTbyBkYXRhWm9vbU1vZGVscyBzaGFyZSBvbmUgYXhpc1Byb3h5IGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgQXhpc1Byb3h5ID0gZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuX2RpbU5hbWUgPSBkaW1OYW1lO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fYXhpc0luZGV4ID0gYXhpc0luZGV4O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuICB0aGlzLl92YWx1ZVdpbmRvdztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fcGVyY2VudFdpbmRvdztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fZGF0YUV4dGVudDtcbiAgLyoqXG4gICAqIHttaW5TcGFuLCBtYXhTcGFuLCBtaW5WYWx1ZVNwYW4sIG1heFZhbHVlU3Bhbn1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbWluTWF4U3BhbjtcbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICovXG5cbiAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9XG4gICAqL1xuXG4gIHRoaXMuX2RhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsOyAvLyAvKipcbiAgLy8gICogQHJlYWRPbmx5XG4gIC8vICAqIEBwcml2YXRlXG4gIC8vICAqL1xuICAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQ7XG59O1xuXG5BeGlzUHJveHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpc1Byb3h5LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBheGlzUHJveHkgaXMgaG9zdGVkIGJ5IGRhdGFab29tTW9kZWwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhvc3RlZEJ5OiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhWm9vbU1vZGVsID09PSBkYXRhWm9vbU1vZGVsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVmFsdWUgY2FuIG9ubHkgYmUgTmFOIG9yIGZpbml0ZSB2YWx1ZS5cbiAgICovXG4gIGdldERhdGFWYWx1ZVdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVdpbmRvdy5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldERhdGFQZXJjZW50V2luZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRXaW5kb3cuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXNNb2RlbHNcbiAgICovXG4gIGdldFRhcmdldFNlcmllc01vZGVsczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoaGVscGVyLmlzQ29vcmRTdXBwb3J0ZWQoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykpKSB7XG4gICAgICAgIHZhciBkaW1OYW1lID0gdGhpcy5fZGltTmFtZTtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICBtYWluVHlwZTogZGltTmFtZSArICdBeGlzJyxcbiAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWUgKyAnQXhpc0luZGV4JyksXG4gICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChkaW1OYW1lICsgJ0F4aXNJZCcpXG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLl9heGlzSW5kZXggPT09IChheGlzTW9kZWwgJiYgYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSkge1xuICAgICAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzZXJpZXNNb2RlbHM7XG4gIH0sXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KHRoaXMuX2RpbU5hbWUgKyAnQXhpcycsIHRoaXMuX2F4aXNJbmRleCk7XG4gIH0sXG4gIGdldE90aGVyQXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpc0NhcnRlc2lhbiA9IGF4aXNEaW0gPT09ICd4JyB8fCBheGlzRGltID09PSAneSc7XG4gICAgdmFyIG90aGVyQXhpc0RpbTtcbiAgICB2YXIgY29vcmRTeXNJbmRleE5hbWU7XG5cbiAgICBpZiAoaXNDYXJ0ZXNpYW4pIHtcbiAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ2dyaWRJbmRleCc7XG4gICAgICBvdGhlckF4aXNEaW0gPSBheGlzRGltID09PSAneCcgPyAneScgOiAneCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ3BvbGFySW5kZXgnO1xuICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ2FuZ2xlJyA/ICdyYWRpdXMnIDogJ2FuZ2xlJztcbiAgICB9XG5cbiAgICB2YXIgZm91bmRPdGhlckF4aXNNb2RlbDtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQob3RoZXJBeGlzRGltICsgJ0F4aXMnLCBmdW5jdGlvbiAob3RoZXJBeGlzTW9kZWwpIHtcbiAgICAgIGlmICgob3RoZXJBeGlzTW9kZWwuZ2V0KGNvb3JkU3lzSW5kZXhOYW1lKSB8fCAwKSA9PT0gKGF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApKSB7XG4gICAgICAgIGZvdW5kT3RoZXJBeGlzTW9kZWwgPSBvdGhlckF4aXNNb2RlbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmRPdGhlckF4aXNNb2RlbDtcbiAgfSxcbiAgZ2V0TWluTWF4U3BhbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fbWluTWF4U3Bhbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9ubHkgY2FsY3VsYXRlIGJ5IGdpdmVuIHJhbmdlIGFuZCB0aGlzLl9kYXRhRXh0ZW50LCBkbyBub3QgY2hhbmdlIGFueXRoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0VmFsdWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZFZhbHVlXVxuICAgKi9cbiAgY2FsY3VsYXRlRGF0YVdpbmRvdzogZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5fZGF0YUV4dGVudDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgc2NhbGUgPSBheGlzTW9kZWwuYXhpcy5zY2FsZTtcblxuICAgIHZhciByYW5nZVByb3BNb2RlID0gdGhpcy5fZGF0YVpvb21Nb2RlbC5nZXRSYW5nZVByb3BNb2RlKCk7XG5cbiAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgIHZhciBwZXJjZW50V2luZG93ID0gW29wdC5zdGFydCwgb3B0LmVuZF07XG4gICAgdmFyIHZhbHVlV2luZG93ID0gW107XG4gICAgZWFjaChbJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhbHVlV2luZG93LnB1c2gob3B0W3Byb3BdICE9IG51bGwgPyBzY2FsZS5wYXJzZShvcHRbcHJvcF0pIDogbnVsbCk7XG4gICAgfSk7IC8vIE5vcm1hbGl6ZSBib3VuZC5cblxuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgYm91bmRWYWx1ZSA9IHZhbHVlV2luZG93W2lkeF07XG4gICAgICB2YXIgYm91bmRQZXJjZW50ID0gcGVyY2VudFdpbmRvd1tpZHhdOyAvLyBOb3RpY2U6IGRhdGFab29tIGlzIGJhc2VkIGVpdGhlciBvbiBgcGVyY2VudFByb3BgICgnc3RhcnQnLCAnZW5kJykgb3JcbiAgICAgIC8vIG9uIGB2YWx1ZVByb3BgICgnc3RhcnRWYWx1ZScsICdlbmRWYWx1ZScpLiBUaGUgZm9ybWVyIG9uZSBpcyBzdWl0YWJsZVxuICAgICAgLy8gZm9yIGNhc2VzIHRoYXQgYSBkYXRhWm9vbSBjb21wb25lbnQgY29udHJvbHMgbXVsdGlwbGUgYXhlcyB3aXRoIGRpZmZlcmVudFxuICAgICAgLy8gdW5pdCBvciBleHRlbnQsIGFuZCB0aGUgbGF0dGVyIG9uZSBpcyBzdWl0YWJsZSBmb3IgYWNjdXJhdGUgem9vbSBieSBwaXhlbFxuICAgICAgLy8gKGUuZy4sIGluIGRhdGFab29tU2VsZWN0KS4gYHZhbHVlUHJvcGAgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSBgcGVyY2VudFByb3BgLFxuICAgICAgLy8gYnV0IGl0IGlzIGF3a3dhcmQgdGhhdCBgcGVyY2VudFByb3BgIGNhbiBub3QgYmUgb2J0YWluZWQgZnJvbSBgdmFsdWVQcm9wYFxuICAgICAgLy8gYWNjdXJhdGVseSAoYmVjYXVzZSBhbGwgb2YgdmFsdWVzIHRoYXQgYXJlIG92ZXJmbG93IHRoZSBgZGF0YUV4dGVudGAgd2lsbFxuICAgICAgLy8gYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJykuIFNvIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBgZGF0YVpvb20uZ2V0UmFuZ2VQcm9wTW9kZSgpYCB0byBtYXJrIHdoaWNoIHByb3AgaXMgdXNlZC5cbiAgICAgIC8vIGByYW5nZVByb3BNb2RlYCBpcyB1cGRhdGVkIG9ubHkgd2hlbiBzZXRPcHRpb24gb3IgZGlzcGF0Y2hBY3Rpb24sIG90aGVyd2lzZVxuICAgICAgLy8gaXQgcmVtYWlucyBpdHMgb3JpZ2luYWwgdmFsdWUuXG5cbiAgICAgIGlmIChyYW5nZVByb3BNb2RlW2lkeF0gPT09ICdwZXJjZW50Jykge1xuICAgICAgICBpZiAoYm91bmRQZXJjZW50ID09IG51bGwpIHtcbiAgICAgICAgICBib3VuZFBlcmNlbnQgPSBwZXJjZW50RXh0ZW50W2lkeF07XG4gICAgICAgIH0gLy8gVXNlIHNjYWxlLnBhcnNlIHRvIG1hdGggcm91bmQgZm9yIGNhdGVnb3J5IG9yIHRpbWUgYXhpcy5cblxuXG4gICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFBlcmNlbnQsIHBlcmNlbnRFeHRlbnQsIGRhdGFFeHRlbnQsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGBwZXJjZW50YCBmcm9tIGB2YWx1ZWAgbWF5IGJlIG5vdCBhY2N1cmF0ZSwgYmVjYXVzZVxuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGNhbiBub3QgYmUgaW52ZXJzZWQsIGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0XG4gICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJ1xuICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFZhbHVlLCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50LCB0cnVlKTtcbiAgICAgIH0gLy8gdmFsdWVXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kVmFsdWUpO1xuICAgICAgLy8gcGVyY2VudFdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRQZXJjZW50KTtcblxuXG4gICAgICB2YWx1ZVdpbmRvd1tpZHhdID0gYm91bmRWYWx1ZTtcbiAgICAgIHBlcmNlbnRXaW5kb3dbaWR4XSA9IGJvdW5kUGVyY2VudDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVXaW5kb3c6IGFzYyh2YWx1ZVdpbmRvdyksXG4gICAgICBwZXJjZW50V2luZG93OiBhc2MocGVyY2VudFdpbmRvdylcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOb3RpY2U6IHJlc2V0IHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSBzZXJpZXMucmVzdG9yZURhdGEoKSBjYWxsZWQsXG4gICAqIHNvIGl0IGlzIHJlY29tbWFuZGVkIHRvIGJlIGNhbGxlZCBpbiBcInByb2Nlc3Mgc3RhZ2VcIiBidXQgbm90IFwibW9kZWwgaW5pdFxuICAgKiBzdGFnZVwiLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U2VyaWVzID0gdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTsgLy8gQ3VsY3VsYXRlIGRhdGEgd2luZG93IGFuZCBkYXRhIGV4dGVudCwgYW5kIHJlY29yZCB0aGVtLlxuXG4gICAgdGhpcy5fZGF0YUV4dGVudCA9IGNhbGN1bGF0ZURhdGFFeHRlbnQodGhpcywgdGhpcy5fZGltTmFtZSwgdGFyZ2V0U2VyaWVzKTsgLy8gdGhpcy5oYXNTZXJpZXNTdGFja2VkID0gZmFsc2U7XG4gICAgLy8gZWFjaCh0YXJnZXRTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAvLyB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG4gICAgLy8gdmFyIGRhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbih0aGlzLl9kaW1OYW1lKTtcbiAgICAvLyB2YXIgc3RhY2tlZERpbWVuc2lvbiA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkRGltZW5zaW9uJyk7XG4gICAgLy8gaWYgKHN0YWNrZWREaW1lbnNpb24gJiYgc3RhY2tlZERpbWVuc2lvbiA9PT0gZGF0YURpbSkge1xuICAgIC8vIHRoaXMuaGFzU2VyaWVzU3RhY2tlZCA9IHRydWU7XG4gICAgLy8gfVxuICAgIC8vIH0sIHRoaXMpO1xuXG4gICAgdmFyIGRhdGFXaW5kb3cgPSB0aGlzLmNhbGN1bGF0ZURhdGFXaW5kb3coZGF0YVpvb21Nb2RlbC5vcHRpb24pO1xuICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICB0aGlzLl9wZXJjZW50V2luZG93ID0gZGF0YVdpbmRvdy5wZXJjZW50V2luZG93O1xuICAgIHNldE1pbk1heFNwYW4odGhpcyk7IC8vIFVwZGF0ZSBheGlzIHNldHRpbmcgdGhlbi5cblxuICAgIHNldEF4aXNNb2RlbCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIHJlc3RvcmU6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IHRoaXMuX3BlcmNlbnRXaW5kb3cgPSBudWxsO1xuICAgIHNldEF4aXNNb2RlbCh0aGlzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIGZpbHRlckRhdGE6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsLCBhcGkpIHtcbiAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICB2YXIgc2VyaWVzTW9kZWxzID0gdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICB2YXIgZmlsdGVyTW9kZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJyk7XG4gICAgdmFyIHZhbHVlV2luZG93ID0gdGhpcy5fdmFsdWVXaW5kb3c7XG5cbiAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGSVhNRVxuICAgIC8vIFRvb2xib3ggbWF5IGhhcyBkYXRhWm9vbSBpbmplY3RlZC4gQW5kIGlmIHRoZXJlIGFyZSBzdGFja2VkIGJhciBjaGFydFxuICAgIC8vIHdpdGggTmFOIGRhdGEsIE5hTiB3aWxsIGJlIGZpbHRlcmVkIGFuZCBzdGFjayB3aWxsIGJlIHdyb25nLlxuICAgIC8vIFNvIHdlIG5lZWQgdG8gZm9yY2UgdGhlIG1vZGUgdG8gYmUgc2V0IGVtcHR5LlxuICAgIC8vIEluIGZlY3QsIGl0IGlzIG5vdCBhIGJpZyBkZWFsIHRoYXQgZG8gbm90IHN1cHBvcnQgZmlsdGVyTW9kZS0nZmlsdGVyJ1xuICAgIC8vIHdoZW4gdXNpbmcgdG9vbGJveCNkYXRhWm9vbSwgdXRpbGwgdG9vbHRpcCNkYXRhWm9vbSBzdXBwb3J0IFwic2luZ2xlIGF4aXNcbiAgICAvLyBzZWxlY3Rpb25cIiBzb21lIGRheSwgd2hpY2ggbWlnaHQgbmVlZCBcImFkYXB0IHRvIGRhdGEgZXh0ZW50IG9uIHRoZVxuICAgIC8vIG90aGVyQXhpc1wiLCB3aGljaCBpcyBkaXNhYmxlZCBieSBmaWx0ZXJNb2RlLSdlbXB0eScuXG4gICAgLy8gQnV0IGN1cnJlbnRseSwgc3RhY2sgaGFzIGJlZW4gZml4ZWQgdG8gYmFzZWQgb24gdmFsdWUgYnV0IG5vdCBpbmRleCxcbiAgICAvLyBzbyB0aGlzIGlzIG5vdCBhbiBpc3N1ZSBhbnkgbW9yZS5cbiAgICAvLyB2YXIgb3RoZXJBeGlzTW9kZWwgPSB0aGlzLmdldE90aGVyQXhpc01vZGVsKCk7XG4gICAgLy8gaWYgKGRhdGFab29tTW9kZWwuZ2V0KCckZnJvbVRvb2xib3gnKVxuICAgIC8vICAgICAmJiBvdGhlckF4aXNNb2RlbFxuICAgIC8vICAgICAmJiBvdGhlckF4aXNNb2RlbC5oYXNTZXJpZXNTdGFja2VkXG4gICAgLy8gKSB7XG4gICAgLy8gICAgIGZpbHRlck1vZGUgPSAnZW1wdHknO1xuICAgIC8vIH1cbiAgICAvLyBUT0RPXG4gICAgLy8gZmlsdGVyTW9kZSAnd2Vha0ZpbHRlcicgYW5kICdlbXB0eScgaXMgbm90IG9wdGltaXplZCBmb3IgaHVnZSBkYXRhIHlldC5cblxuXG4gICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgZGF0YURpbXMgPSBzZXJpZXNEYXRhLm1hcERpbWVuc2lvbihheGlzRGltLCB0cnVlKTtcblxuICAgICAgaWYgKCFkYXRhRGltcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ3dlYWtGaWx0ZXInKSB7XG4gICAgICAgIHNlcmllc0RhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlZnRPdXQ7XG4gICAgICAgICAgdmFyIHJpZ2h0T3V0O1xuICAgICAgICAgIHZhciBoYXNWYWx1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YURpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmllc0RhdGEuZ2V0KGRhdGFEaW1zW2ldLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHRoaXNIYXNWYWx1ZSA9ICFpc05hTih2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdGhpc0xlZnRPdXQgPSB2YWx1ZSA8IHZhbHVlV2luZG93WzBdO1xuICAgICAgICAgICAgdmFyIHRoaXNSaWdodE91dCA9IHZhbHVlID4gdmFsdWVXaW5kb3dbMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzSGFzVmFsdWUgJiYgIXRoaXNMZWZ0T3V0ICYmICF0aGlzUmlnaHRPdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXNMZWZ0T3V0ICYmIChsZWZ0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzUmlnaHRPdXQgJiYgKHJpZ2h0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgfSAvLyBJZiBib3RoIGxlZnQgb3V0IGFuZCByaWdodCBvdXQsIGRvIG5vdCBmaWx0ZXIuXG5cblxuICAgICAgICAgIHJldHVybiBoYXNWYWx1ZSAmJiBsZWZ0T3V0ICYmIHJpZ2h0T3V0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHt9O1xuICAgICAgICAgICAgcmFuZ2VbZGltXSA9IHZhbHVlV2luZG93OyAvLyBjb25zb2xlLnRpbWUoJ3NlbGVjdCcpO1xuXG4gICAgICAgICAgICBzZXJpZXNEYXRhLnNlbGVjdFJhbmdlKHJhbmdlKTsgLy8gY29uc29sZS50aW1lRW5kKCdzZWxlY3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHNlcmllc0RhdGEuc2V0QXBwcm94aW1hdGVFeHRlbnQodmFsdWVXaW5kb3csIGRpbSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSB2YWx1ZVdpbmRvd1swXSAmJiB2YWx1ZSA8PSB2YWx1ZVdpbmRvd1sxXTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFFeHRlbnQoYXhpc1Byb3h5LCBheGlzRGltLCBzZXJpZXNNb2RlbHMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgIGlmIChzZXJpZXNEYXRhKSB7XG4gICAgICBlYWNoKHNlcmllc0RhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0sIHRydWUpLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHZhciBzZXJpZXNFeHRlbnQgPSBzZXJpZXNEYXRhLmdldEFwcHJveGltYXRlRXh0ZW50KGRpbSk7XG4gICAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRhdGFFeHRlbnRbMV0gPCBkYXRhRXh0ZW50WzBdKSB7XG4gICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gIH0gLy8gSXQgaXMgaW1wb3J0YW50IHRvIGdldCBcImNvbnNpc3RlbnRcIiBleHRlbnQgd2hlbiBtb3JlIHRoZW4gb25lIGF4ZXMgaXNcbiAgLy8gY29udHJvbGxlZCBieSBhIGBkYXRhWm9vbWAsIG90aGVyd2lzZSB0aG9zZSBheGVzIHdpbGwgbm90IGJlIHN5bmNocm9uaXplZFxuICAvLyB3aGVuIHpvb21pbmcuIEJ1dCBpdCBpcyBkaWZmaWN1bHQgdG8ga25vdyB3aGF0IGlzIFwiY29uc2lzdGVudFwiLCBjb25zaWRlcmluZ1xuICAvLyBheGVzIGhhdmUgZGlmZmVyZW50IHR5cGUgb3IgZXZlbiBkaWZmZXJlbnQgbWVhbmluZ3MgKEZvciBleGFtcGxlLCB0d29cbiAgLy8gdGltZSBheGVzIGFyZSB1c2VkIHRvIGNvbXBhcmUgZGF0YSBvZiB0aGUgc2FtZSBkYXRlIGluIGRpZmZlcmVudCB5ZWFycykuXG4gIC8vIFNvIGJhc2ljYWxseSBkYXRhWm9vbSBqdXN0IG9idGFpbnMgZXh0ZW50IGJ5IHNlcmllcy5kYXRhIChpbiBjYXRlZ29yeSBheGlzXG4gIC8vIGV4dGVudCBjYW4gYmUgb2J0YWluZWQgZnJvbSBheGlzLmRhdGEpLlxuICAvLyBOZXZlcnRoZWxlc3MsIHVzZXIgY2FuIHNldCBtaW4vbWF4L3NjYWxlIG9uIGF4ZXMgdG8gbWFrZSBleHRlbnQgb2YgYXhlc1xuICAvLyBjb25zaXN0ZW50LlxuXG5cbiAgZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCk7XG4gIHJldHVybiBkYXRhRXh0ZW50O1xufVxuXG5mdW5jdGlvbiBmaXhFeHRlbnRCeUF4aXMoYXhpc1Byb3h5LCBkYXRhRXh0ZW50KSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBtaW4gPSBheGlzTW9kZWwuZ2V0TWluKHRydWUpOyAvLyBGb3IgY2F0ZWdvcnkgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgZXh0ZW50IGlzIGRldGVybWluZWRcbiAgLy8gYnkgYXhpcy5kYXRhIGJ5IGRlZmF1bHQuXG5cbiAgdmFyIGlzQ2F0ZWdvcnlBeGlzID0gYXhpc01vZGVsLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknO1xuICB2YXIgYXhpc0RhdGFMZW4gPSBpc0NhdGVnb3J5QXhpcyAmJiBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcygpLmxlbmd0aDtcblxuICBpZiAobWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicgJiYgdHlwZW9mIG1pbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFFeHRlbnRbMF0gPSBtaW47XG4gIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHtcbiAgICBkYXRhRXh0ZW50WzBdID0gYXhpc0RhdGFMZW4gPiAwID8gMCA6IE5hTjtcbiAgfVxuXG4gIHZhciBtYXggPSBheGlzTW9kZWwuZ2V0TWF4KHRydWUpO1xuXG4gIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiB0eXBlb2YgbWF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUV4dGVudFsxXSA9IG1heDtcbiAgfSBlbHNlIGlmIChpc0NhdGVnb3J5QXhpcykge1xuICAgIGRhdGFFeHRlbnRbMV0gPSBheGlzRGF0YUxlbiA+IDAgPyBheGlzRGF0YUxlbiAtIDEgOiBOYU47XG4gIH1cblxuICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3NjYWxlJywgdHJ1ZSkpIHtcbiAgICBkYXRhRXh0ZW50WzBdID4gMCAmJiAoZGF0YUV4dGVudFswXSA9IDApO1xuICAgIGRhdGFFeHRlbnRbMV0gPCAwICYmIChkYXRhRXh0ZW50WzFdID0gMCk7XG4gIH0gLy8gRm9yIHZhbHVlIGF4aXMsIGlmIG1pbi9tYXgvc2NhbGUgYXJlIG5vdCBzZXQsIHdlIGp1c3QgdXNlIHRoZSBleHRlbnQgb2J0YWluZWRcbiAgLy8gYnkgc2VyaWVzIGRhdGEsIHdoaWNoIG1heSBiZSBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgZXh0ZW50IGNhbGN1bGF0ZWQgYnlcbiAgLy8gYGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnRgLiBCdXQgdGhlIGRpZmZlcmVudCBqdXN0IGFmZmVjdHMgdGhlIGV4cGVyaWVuY2UgYVxuICAvLyBsaXR0bGUgd2hlbiB6b29taW5nLiBTbyBpdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lIHVzZXJzIHJlcXVpcmUgaXQgc3Ryb25nbHkuXG5cblxuICByZXR1cm4gZGF0YUV4dGVudDtcbn1cblxuZnVuY3Rpb24gc2V0QXhpc01vZGVsKGF4aXNQcm94eSwgaXNSZXN0b3JlKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBwZXJjZW50V2luZG93ID0gYXhpc1Byb3h5Ll9wZXJjZW50V2luZG93O1xuICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93O1xuXG4gIGlmICghcGVyY2VudFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfSAvLyBbMCwgNTAwXTogYXJiaXRyYXJ5IHZhbHVlLCBndWVzcyBheGlzIGV4dGVudC5cblxuXG4gIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApOyAvLyBpc1Jlc3RvcmUgb3IgaXNGdWxsXG5cbiAgdmFyIHVzZU9yaWdpbiA9IGlzUmVzdG9yZSB8fCBwZXJjZW50V2luZG93WzBdID09PSAwICYmIHBlcmNlbnRXaW5kb3dbMV0gPT09IDEwMDtcbiAgYXhpc01vZGVsLnNldFJhbmdlKHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMF0udG9GaXhlZChwcmVjaXNpb24pLCB1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzFdLnRvRml4ZWQocHJlY2lzaW9uKSk7XG59XG5cbmZ1bmN0aW9uIHNldE1pbk1heFNwYW4oYXhpc1Byb3h5KSB7XG4gIHZhciBtaW5NYXhTcGFuID0gYXhpc1Byb3h5Ll9taW5NYXhTcGFuID0ge307XG4gIHZhciBkYXRhWm9vbU1vZGVsID0gYXhpc1Byb3h5Ll9kYXRhWm9vbU1vZGVsO1xuICBlYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgbWluTWF4U3BhblttaW5NYXggKyAnU3BhbiddID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1NwYW4nKTsgLy8gbWluVmFsdWVTcGFuIGFuZCBtYXhWYWx1ZVNwYW4gaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1pblNwYW4gYW5kIG1heFNwYW5cblxuICAgIHZhciB2YWx1ZVNwYW4gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnVmFsdWVTcGFuJyk7XG5cbiAgICBpZiAodmFsdWVTcGFuICE9IG51bGwpIHtcbiAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1ZhbHVlU3BhbiddID0gdmFsdWVTcGFuO1xuICAgICAgdmFsdWVTcGFuID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXMuc2NhbGUucGFyc2UodmFsdWVTcGFuKTtcblxuICAgICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYXRhRXh0ZW50ID0gYXhpc1Byb3h5Ll9kYXRhRXh0ZW50O1xuICAgICAgICBtaW5NYXhTcGFuW21pbk1heCArICdTcGFuJ10gPSBudW1iZXJVdGlsLmxpbmVhck1hcChkYXRhRXh0ZW50WzBdICsgdmFsdWVTcGFuLCBkYXRhRXh0ZW50LCBbMCwgMTAwXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQXhpc1Byb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = __webpack_require__(/*! ../../config */ \"./node_modules/echarts/lib/config.js\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(/*! ../../echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar env = __webpack_require__(/*! zrender/lib/core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar modelUtil = __webpack_require__(/*! ../../util/model */ \"./node_modules/echarts/lib/util/model.js\");\n\nvar helper = __webpack_require__(/*! ./helper */ \"./node_modules/echarts/lib/component/dataZoom/helper.js\");\n\nvar AxisProxy = __webpack_require__(/*! ./AxisProxy */ \"./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // ec2xAxisIndexyAxisIndexscatterdataZoom\n      // Grid.js#getScaleByOptiontimelogaxis type\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // seriesxAxisIndexyAxisIndex\n    // series.type === scatter\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanM/M2E1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIEF4aXNQcm94eSA9IHJlcXVpcmUoXCIuL0F4aXNQcm94eVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBlYWNoQXhpc0RpbSA9IGhlbHBlci5lYWNoQXhpc0RpbTtcbnZhciBEYXRhWm9vbU1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcycsICd6QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcyddLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgLy8gSGlnaGVyIHRoYW4gbm9ybWFsIGNvbXBvbmVudCAoejogMikuXG4gICAgb3JpZW50OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYXV0byBieSBheGlzSW5kZXguIFBvc3NpYmxlIHZhbHVlOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcuXG4gICAgeEF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCBob3Jpem9udGFsIGNhdGVnb3J5IGF4aXMuXG4gICAgeUF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCB2ZXJ0aWNhbCBjYXRlZ29yeSBheGlzLlxuICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLFxuICAgIC8vIFBvc3NpYmxlIHZhbHVlczogJ2ZpbHRlcicgb3IgJ2VtcHR5JyBvciAnd2Vha0ZpbHRlcicuXG4gICAgLy8gJ2ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvbiBpc1xuICAgIC8vICAgICAgICAgIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIGlmIG9uZSBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBpcyBvdXQgb2YgdGhlIHdpbmRvdy5cbiAgICAvLyAnd2Vha0ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvblxuICAgIC8vICAgICAgICAgIGlzIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIG9ubHkgaWYgYWxsICBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgb3V0IG9mIHRoZSBzYW1lXG4gICAgLy8gICAgICAgICAgc2lkZSBvZiB0aGUgd2luZG93LlxuICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgLy8gICAgICAgICAgVGhpcyBvcHRpb24gaXMgYXBwbGljYWJsZSB3aGVuIHVzZXIgc2hvdWxkIG5vdCBuZWdsZWN0XG4gICAgLy8gICAgICAgICAgdGhhdCB0aGVyZSBhcmUgc29tZSBkYXRhIGl0ZW1zIG91dCBvZiB3aW5kb3cuXG4gICAgLy8gJ25vbmUnOiBEbyBub3QgZmlsdGVyLlxuICAgIC8vIFRha2luZyBsaW5lIGNoYXJ0IGFzIGFuIGV4YW1wbGUsIGxpbmUgd2lsbCBiZSBicm9rZW4gaW5cbiAgICAvLyB0aGUgZmlsdGVyZWQgcG9pbnRzIHdoZW4gZmlsdGVyTW9kZWwgaXMgc2V0IHRvICdlbXB0eScsIGJ1dFxuICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cbiAgICB0aHJvdHRsZTogbnVsbCxcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gYnkgdGhlIGZpeGVkIHJhdGUsIGF2b2lkIGZyZXF1ZW5jeS5cbiAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgIC8vIElmIGFuaW1hdGlvbiA9PT0gdHJ1ZSBhbmQgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUgPiAwLFxuICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMTAwLCBvdGhlcndpc2UgMjAuXG4gICAgc3RhcnQ6IDAsXG4gICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgIGVuZDogMTAwLFxuICAgIC8vIEVuZCBwZXJjZW50LiAwIH4gMTAwXG4gICAgc3RhcnRWYWx1ZTogbnVsbCxcbiAgICAvLyBTdGFydCB2YWx1ZS4gSWYgc3RhcnRWYWx1ZSBzcGVjaWZpZWQsIHN0YXJ0IGlzIGlnbm9yZWQuXG4gICAgZW5kVmFsdWU6IG51bGwsXG4gICAgLy8gRW5kIHZhbHVlLiBJZiBlbmRWYWx1ZSBzcGVjaWZpZWQsIGVuZCBpcyBpZ25vcmVkLlxuICAgIG1pblNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1heFNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1pblZhbHVlU3BhbjogbnVsbCxcbiAgICAvLyBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cbiAgICBtYXhWYWx1ZVNwYW46IG51bGwsXG4gICAgLy8gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICByYW5nZU1vZGU6IG51bGwgLy8gQXJyYXksIGNhbiBiZSAndmFsdWUnIG9yICdwZXJjZW50Jy5cblxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGFJbmZvID0ge307XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIHRoaXMudGV4dFN0eWxlTW9kZWw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogJ3BlcmNlbnQnIG9yICd2YWx1ZSdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2VQcm9wTW9kZSA9IFsncGVyY2VudCcsICdwZXJjZW50J107XG4gICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgcmF3T3B0aW9uID0gcmV0cmlldmVSYXcobmV3T3B0aW9uKTsgLy9GSVggIzI1OTFcblxuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLmRvSW5pdChyYXdPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkb0luaXQ6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBEaXNhYmxlIHJlYWx0aW1lIHZpZXcgdXBkYXRlIGlmIGNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICB1cGRhdGVSYW5nZVVzZSh0aGlzLCByYXdPcHRpb24pO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlIGlmIHRoZXlcbiAgICAgIC8vIGJvdGggc2V0LCBidXQgd2Ugc2hvdWxkIG1ha2UgY2hhcnQuc2V0T3B0aW9uKHtlbmRWYWx1ZTogMTAwMH0pXG4gICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvcE1vZGVbaW5kZXhdID09PSAndmFsdWUnKSB7XG4gICAgICAgIHRoaXNPcHRpb25bbmFtZXNbMF1dID0gbnVsbDtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgYW5kIHVzZSB0aGUgbWVyZ2UgcmVzdWx0LlxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy50ZXh0U3R5bGVNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgdGhpcy5fcmVzZXRUYXJnZXQoKTtcblxuICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveGllcyA9IHRoaXMuX2F4aXNQcm94aWVzO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtheGlzSW5kZXhdOyAvLyBJZiBleGlzdHMsIHNoYXJlIGF4aXNQcm94eSB3aXRoIG90aGVyIGRhdGFab29tTW9kZWxzLlxuXG4gICAgICB2YXIgYXhpc1Byb3h5ID0gYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgfHwgKCAvLyBVc2UgdGhlIGZpcnN0IGRhdGFab29tTW9kZWwgYXMgdGhlIG1haW4gbW9kZWwgb2YgYXhpc1Byb3h5LlxuICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCwgdGhpcywgZWNNb2RlbCkpOyAvLyBGSVhNRVxuICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgIGF4aXNQcm94aWVzW2RpbU5hbWVzLm5hbWUgKyAnXycgKyBheGlzSW5kZXhdID0gYXhpc1Byb3h5O1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgIHZhciBhdXRvTW9kZSA9IHRoaXMuX2p1ZGdlQXV0b01vZGUoKTtcblxuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIGF4aXNJbmRleE5hbWUgPSBkaW1OYW1lcy5heGlzSW5kZXg7XG4gICAgICB0aGlzT3B0aW9uW2F4aXNJbmRleE5hbWVdID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkodGhpc09wdGlvbltheGlzSW5kZXhOYW1lXSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXV0b01vZGUgPT09ICdheGlzSW5kZXgnKSB7XG4gICAgICB0aGlzLl9hdXRvU2V0QXhpc0luZGV4KCk7XG4gICAgfSBlbHNlIGlmIChhdXRvTW9kZSA9PT0gJ29yaWVudCcpIHtcbiAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfanVkZ2VBdXRvTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF1dG8gc2V0IG9ubHkgd29ya3MgZm9yIHNldE9wdGlvbiBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAvLyBvcHRpb24gaXMgT0suXG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgaGFzSW5kZXhTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgIC8vIFdoZW4gdXNlciBzZXQgYXhpc0luZGV4IGFzIGEgZW1wdHkgYXJyYXksIHdlIHRoaW5rIHRoYXQgdXNlciBzcGVjaWZ5IGF4aXNJbmRleFxuICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJlZC5cbiAgICAgIGlmICh0aGlzT3B0aW9uW2RpbU5hbWVzLmF4aXNJbmRleF0gIT0gbnVsbCkge1xuICAgICAgICBoYXNJbmRleFNwZWNpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgaWYgKG9yaWVudCA9PSBudWxsICYmIGhhc0luZGV4U3BlY2lmaWVkKSB7XG4gICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgfSBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgIGlmIChvcmllbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uLm9yaWVudCA9ICdob3Jpem9udGFsJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdheGlzSW5kZXgnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF1dG9BeGlzSW5kZXggPSB0cnVlO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHM7XG5cbiAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cbiAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICBpZiAoZGVwZW5kZW50TW9kZWxzW2RpbU5hbWUgKyAnQXhpcyddLmxlbmd0aCkge1xuICAgICAgICB0aGlzT3B0aW9uW2RpbU5hbWUgKyAnQXhpc0luZGV4J10gPSBbMF07XG4gICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGVwZW5kZW50TW9kZWxzLnNpbmdsZUF4aXMsIGZ1bmN0aW9uIChzaW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICB0aGlzT3B0aW9uLnNpbmdsZUF4aXNJbmRleCA9IFtzaW5nbGVBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgYXV0b0F4aXNJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKGNvbnNpZGVyIHBvbGFyKVxuICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgIGlmICghYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgYXhpc01vZGVscyA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF4aXNNb2RlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdID0gYXhpc0luZGljZXM7XG5cbiAgICAgICAgaWYgKGF4aXNJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDov5nph4zmmK/lhbzlrrllYzLnmoTlhpnms5XvvIjmsqHmjIflrpp4QXhpc0luZGV45ZKMeUF4aXNJbmRleOaXtuaKinNjYXR0ZXLlkozlj4zmlbDlgLzovbTmipjmn7HnurPlhaVkYXRhWm9vbeaOp+WItu+8ie+8jFxuICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBkYXRhWm9vbSBjb21wb25lbnQgYXV0byBhZG9wdHMgc2VyaWVzIHRoYXQgcmVmZXJlbmNlIHRvXG4gICAgICAvLyBib3RoIHhBeGlzIGFuZCB5QXhpcyB3aGljaCB0eXBlIGlzICd2YWx1ZScuXG4gICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcbiAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHZhciBheGlzSWQgPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0lkKTtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgIG1haW5UeXBlOiBkaW1OYW1lcy5heGlzLFxuICAgICAgICAgICAgICBpbmRleDogYXhpc0luZGV4LFxuICAgICAgICAgICAgICBpZDogYXhpc0lkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGF4aXNJbmRpY2VzLCBheGlzSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICBheGlzSW5kaWNlcy5wdXNoKGF4aXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0T3JpZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbTsgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuXG4gICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICFkaW0gJiYgKGRpbSA9IGRpbU5hbWVzLm5hbWUpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMub3B0aW9uLm9yaWVudCA9IGRpbSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Nlcmllc0hhc0FsbEF4ZXNUeXBlT2Y6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIOmcgOimgXNlcmllc+eahHhBeGlzSW5kZXjlkox5QXhpc0luZGV46YO96aaW5YWI6Ieq5Yqo6K6+572u5LiK44CCXG4gICAgLy8g5L6L5aaCc2VyaWVzLnR5cGUgPT09IHNjYXR0ZXLml7bjgIJcbiAgICB2YXIgaXMgPSB0cnVlO1xuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIHNlcmllc0F4aXNJbmRleCA9IHNlcmllc01vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSAhPT0gYXhpc1R5cGUpIHtcbiAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgLy8gV2hlbiBmaXJzdCB0aW1lIHVzZXIgc2V0IHRocm90dGxlLCBhdXRvIHRocm90dGxlIGVuZHMuXG4gICAgaWYgKHJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgdGhpcy5fYXV0b1Rocm90dGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG5cbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBmaXJzdEF4aXNNb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAqL1xuICBlYWNoVGFyZ2V0QXhpczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBlYWNoKHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCksIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBkaW1OYW1lcywgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNQcm94aWVzW2RpbU5hbWUgKyAnXycgKyBheGlzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBJZiBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmdldEF4aXNQcm94eShkaW1OYW1lLCBheGlzSW5kZXgpO1xuICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgKi9cbiAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBJZiBvbmx5IG9uZSBvZiAnc3RhcnQnIGFuZCAnc3RhcnRWYWx1ZScgaXMgbm90IG51bGwvdW5kZWZpbmVkLCB0aGUgb3RoZXJcbiAgICAgIC8vIHNob3VsZCBiZSBjbGVhcmVkLCB3aGljaCBlbmFibGUgY2xlYXIgdGhlIG9wdGlvbi5cbiAgICAgIC8vIElmIGJvdGggb2YgdGhlbSBhcmUgbm90IHNldCwga2VlcCBvcHRpb24gd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUsIHdoaWNoXG4gICAgICAvLyBlbmFibGUgdXNlIG9ubHkgc2V0IHN0YXJ0IGJ1dCBub3Qgc2V0IGVuZCB3aGVuIGNhbGxpbmcgYGRpc3BhdGNoQWN0aW9uYC5cbiAgICAgIC8vIFRoZSBzYW1lIGFzICdlbmQnIGFuZCAnZW5kVmFsdWUnLlxuICAgICAgaWYgKG9wdFtuYW1lc1swXV0gIT0gbnVsbCB8fCBvcHRbbmFtZXNbMV1dICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9uW25hbWVzWzBdXSA9IG9wdFtuYW1lc1swXV07XG4gICAgICAgIG9wdGlvbltuYW1lc1sxXV0gPSBvcHRbbmFtZXNbMV1dO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgICFpZ25vcmVVcGRhdGVSYW5nZVVzZyAmJiB1cGRhdGVSYW5nZVVzZSh0aGlzLCBvcHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbc3RhcnRQZXJjZW50LCBlbmRQZXJjZW50XVxuICAgKi9cbiAgZ2V0UGVyY2VudFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICByZXR1cm4gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc0RpbU5hbWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICovXG4gIGdldFZhbHVlUmFuZ2U6IGZ1bmN0aW9uIChheGlzRGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltTmFtZSwgYXhpc0luZGV4KS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2F4aXNNb2RlbF0gSWYgYXhpc01vZGVsIGdpdmVuLCBmaW5kIGF4aXNQcm94eVxuICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGF4aXNNb2RlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5fVxuICAgKi9cbiAgZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5OiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuIGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5O1xuICAgIH0gLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuXG5cbiAgICB2YXIgYXhpc1Byb3hpZXMgPSB0aGlzLl9heGlzUHJveGllcztcblxuICAgIGZvciAodmFyIGtleSBpbiBheGlzUHJveGllcykge1xuICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIGhvc3RlZCBheGlzIGZpbmQgbm90IGhvc3RlZCBheGlzUHJveHkuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBkYXRhWm9vbU1vZGVsMSBhbmQgZGF0YVpvb21Nb2RlbDIgY29udHJvbCB0aGUgc2FtZSBheGlzLFxuICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgIC8vIHNob3VsZCBmb2xsb3cgYXhpc1Byb3h5LlxuICAgIC8vIChXZSBlbmNvdW50ZXIgdGhpcyBwcm9ibGVtIGluIHRvb2xib3ggZGF0YSB6b29tLilcblxuXG4gICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0UmFuZ2VQcm9wTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXRyaWV2ZVJhdyhvcHRpb24pIHtcbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvcHRpb24uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHJldFtuYW1lXSA9IG9wdGlvbltuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSYW5nZVVzZShkYXRhWm9vbU1vZGVsLCByYXdPcHRpb24pIHtcbiAgdmFyIHJhbmdlUHJvcE1vZGUgPSBkYXRhWm9vbU1vZGVsLl9yYW5nZVByb3BNb2RlO1xuICB2YXIgcmFuZ2VNb2RlSW5PcHRpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgncmFuZ2VNb2RlJyk7XG4gIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgIHZhciBwZXJjZW50U3BlY2lmaWVkID0gcmF3T3B0aW9uW25hbWVzWzBdXSAhPSBudWxsO1xuICAgIHZhciB2YWx1ZVNwZWNpZmllZCA9IHJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbDtcblxuICAgIGlmIChwZXJjZW50U3BlY2lmaWVkICYmICF2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSBlbHNlIGlmICghcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAndmFsdWUnO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VNb2RlSW5PcHRpb24pIHtcbiAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gcmFuZ2VNb2RlSW5PcHRpb25baW5kZXhdO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudFNwZWNpZmllZCkge1xuICAgICAgLy8gcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZFxuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSAvLyBlbHNlIHJlbWFpbiBpdHMgb3JpZ2luYWwgc2V0dGluZy5cblxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21Nb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar ComponentView = __webpack_require__(/*! ../../view/Component */ \"./node_modules/echarts/lib/view/Component.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tVmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzPzdkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZShcIi4uLy4uL3ZpZXcvQ29tcG9uZW50XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX2RlZmF1bHQgPSBDb21wb25lbnRWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCB0aGUgZmlyc3QgdGFyZ2V0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0ge1xuICAgKiAgICAgICAgICAgICAgICAgICBncmlkOiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW2F4aXMxLCBheGlzM10sIGNvb3JkSW5kZXg6IDF9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDEsIGF4aXNNb2RlbHM6IFtheGlzMCwgYXhpczJdLCBjb29yZEluZGV4OiAwfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgICAgICAgICAgICBdLCAgLy8gY2FydGVzaWFucyBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICogICAgICAgICAgICAgICAgICAgcG9sYXI6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczRdLCBjb29yZEluZGV4OiAwfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgICAgICAgICAgICBdLCAgLy8gcG9sYXJzIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICBzaW5nbGVBeGlzOiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW10sIGNvb3JkSW5kZXg6IDB9XG4gICAqICAgICAgICAgICAgICAgICAgIF1cbiAgICovXG4gIGdldFRhcmdldENvb3JkSW5mbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBjb29yZFN5c0xpc3RzID0ge307XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCkge1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCk7XG5cbiAgICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgICAgICBjb29yZE1vZGVsICYmIHNhdmUoY29vcmRNb2RlbCwgYXhpc01vZGVsLCBjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdIHx8IChjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdID0gW10pLCBjb29yZE1vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHNhdmUoY29vcmRNb2RlbCwgYXhpc01vZGVsLCBzdG9yZSwgY29vcmRJbmRleCkge1xuICAgICAgdmFyIGl0ZW07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0b3JlW2ldLm1vZGVsID09PSBjb29yZE1vZGVsKSB7XG4gICAgICAgICAgaXRlbSA9IHN0b3JlW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBzdG9yZS5wdXNoKGl0ZW0gPSB7XG4gICAgICAgICAgbW9kZWw6IGNvb3JkTW9kZWwsXG4gICAgICAgICAgYXhpc01vZGVsczogW10sXG4gICAgICAgICAgY29vcmRJbmRleDogY29vcmRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5heGlzTW9kZWxzLnB1c2goYXhpc01vZGVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRTeXNMaXN0cztcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseWheel: false,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsLmpzP2ExOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZShcIi4vRGF0YVpvb21Nb2RlbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21Nb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uaW5zaWRlJyxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAvLyBXaGV0aGVyIGRpc2FibGUgdGhpcyBpbnNpZGUgem9vbS5cbiAgICB6b29tTG9jazogZmFsc2UsXG4gICAgLy8gV2hldGhlciBkaXNhYmxlIHpvb20gYnV0IG9ubHkgcGFuLlxuICAgIHpvb21Pbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgLy8gQ2FuIGJlOiB0cnVlIC8gZmFsc2UgLyAnc2hpZnQnIC8gJ2N0cmwnIC8gJ2FsdCcuXG4gICAgbW92ZU9uTW91c2VNb3ZlOiB0cnVlLFxuICAgIC8vIENhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuICAgIG1vdmVPbk1vdXNlV2hlZWw6IGZhbHNlLFxuICAgIC8vIENhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuICAgIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlOiB0cnVlXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar DataZoomView = __webpack_require__(/*! ./DataZoomView */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\");\n\nvar sliderMove = __webpack_require__(/*! ../helper/sliderMove */ \"./node_modules/echarts/lib/component/helper/sliderMove.js\");\n\nvar roams = __webpack_require__(/*! ./roams */ \"./node_modules/echarts/lib/component/dataZoom/roams.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Hance the `throttle` util ensures to preserve command order,\n    // here simply updating range all the time will not cause missing\n    // any of the the roam change.\n\n    this._range = dataZoomModel.getPercentRange(); // Reset controllers.\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var getRange = {};\n        zrUtil.each(['pan', 'zoom', 'scrollMove'], function (eventName) {\n          getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName);\n        }, this);\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          dataZoomModel: dataZoomModel,\n          getRange: getRange\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  }\n});\nvar roamHandlers = {\n  /**\n   * @this {module:echarts/component/dataZoom/InsideZoomView}\n   */\n  zoom: function (coordInfo, coordSysName, controller, e) {\n    var lastRange = this._range;\n    var range = lastRange.slice(); // Calculate transform by the first axis.\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [e.originX, e.originY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    var scale = Math.max(1 / e.scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    this._range = range;\n\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  },\n\n  /**\n   * @this {module:echarts/component/dataZoom/InsideZoomView}\n   */\n  pan: makeMover(function (range, axisModel, coordInfo, coordSysName, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysName]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordInfo);\n    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n  }),\n\n  /**\n   * @this {module:echarts/component/dataZoom/InsideZoomView}\n   */\n  scrollMove: makeMover(function (range, axisModel, coordInfo, coordSysName, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysName]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordInfo);\n    return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;\n  })\n};\n\nfunction makeMover(getPercentDelta) {\n  return function (coordInfo, coordSysName, controller, e) {\n    var lastRange = this._range;\n    var range = lastRange.slice(); // Calculate transform by the first axis.\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e);\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    this._range = range;\n\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  };\n}\n\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qcz8zMmExIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoXCIuL0RhdGFab29tVmlld1wiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbnZhciByb2FtcyA9IHJlcXVpcmUoXCIuL3JvYW1zXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xudmFyIEluc2lkZVpvb21WaWV3ID0gRGF0YVpvb21WaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5pbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAvKipcbiAgICAgKiAndGhyb3R0bGUnIGlzIHVzZWQgaW4gdGhpcy5kaXNwYXRjaEFjdGlvbiwgc28gd2Ugc2F2ZSByYW5nZVxuICAgICAqIHRvIGF2b2lkIG1pc3Npbmcgc29tZSAncGFuJyBpbmZvLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3JhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIEluc2lkZVpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbmRlcicsIGFyZ3VtZW50cyk7IC8vIEhhbmNlIHRoZSBgdGhyb3R0bGVgIHV0aWwgZW5zdXJlcyB0byBwcmVzZXJ2ZSBjb21tYW5kIG9yZGVyLFxuICAgIC8vIGhlcmUgc2ltcGx5IHVwZGF0aW5nIHJhbmdlIGFsbCB0aGUgdGltZSB3aWxsIG5vdCBjYXVzZSBtaXNzaW5nXG4gICAgLy8gYW55IG9mIHRoZSB0aGUgcm9hbSBjaGFuZ2UuXG5cbiAgICB0aGlzLl9yYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7IC8vIFJlc2V0IGNvbnRyb2xsZXJzLlxuXG4gICAgenJVdGlsLmVhY2godGhpcy5nZXRUYXJnZXRDb29yZEluZm8oKSwgZnVuY3Rpb24gKGNvb3JkSW5mb0xpc3QsIGNvb3JkU3lzTmFtZSkge1xuICAgICAgdmFyIGFsbENvb3JkSWRzID0genJVdGlsLm1hcChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgIHJldHVybiByb2Ftcy5nZW5lcmF0ZUNvb3JkSWQoY29vcmRJbmZvLm1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgenJVdGlsLmVhY2goY29vcmRJbmZvTGlzdCwgZnVuY3Rpb24gKGNvb3JkSW5mbykge1xuICAgICAgICB2YXIgY29vcmRNb2RlbCA9IGNvb3JkSW5mby5tb2RlbDtcbiAgICAgICAgdmFyIGdldFJhbmdlID0ge307XG4gICAgICAgIHpyVXRpbC5lYWNoKFsncGFuJywgJ3pvb20nLCAnc2Nyb2xsTW92ZSddLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgZ2V0UmFuZ2VbZXZlbnROYW1lXSA9IGJpbmQocm9hbUhhbmRsZXJzW2V2ZW50TmFtZV0sIHRoaXMsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJvYW1zLnJlZ2lzdGVyKGFwaSwge1xuICAgICAgICAgIGNvb3JkSWQ6IHJvYW1zLmdlbmVyYXRlQ29vcmRJZChjb29yZE1vZGVsKSxcbiAgICAgICAgICBhbGxDb29yZElkczogYWxsQ29vcmRJZHMsXG4gICAgICAgICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uY29udGFpblBvaW50KFt4LCB5XSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgICAgIGRhdGFab29tTW9kZWw6IGRhdGFab29tTW9kZWwsXG4gICAgICAgICAgZ2V0UmFuZ2U6IGdldFJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHJvYW1zLnVucmVnaXN0ZXIodGhpcy5hcGksIHRoaXMuZGF0YVpvb21Nb2RlbC5pZCk7XG4gICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcmFuZ2UgPSBudWxsO1xuICB9XG59KTtcbnZhciByb2FtSGFuZGxlcnMgPSB7XG4gIC8qKlxuICAgKiBAdGhpcyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3fVxuICAgKi9cbiAgem9vbTogZnVuY3Rpb24gKGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBlKSB7XG4gICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciByYW5nZSA9IGxhc3RSYW5nZS5zbGljZSgpOyAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuXG4gICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkSW5mby5heGlzTW9kZWxzWzBdO1xuXG4gICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlyZWN0aW9uSW5mbyA9IGdldERpcmVjdGlvbkluZm9bY29vcmRTeXNOYW1lXShudWxsLCBbZS5vcmlnaW5YLCBlLm9yaWdpblldLCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbyk7XG4gICAgdmFyIHBlcmNlbnRQb2ludCA9IChkaXJlY3Rpb25JbmZvLnNpZ25hbCA+IDAgPyBkaXJlY3Rpb25JbmZvLnBpeGVsU3RhcnQgKyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoIC0gZGlyZWN0aW9uSW5mby5waXhlbCA6IGRpcmVjdGlvbkluZm8ucGl4ZWwgLSBkaXJlY3Rpb25JbmZvLnBpeGVsU3RhcnQpIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aCAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSArIHJhbmdlWzBdO1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KDEgLyBlLnNjYWxlLCAwKTtcbiAgICByYW5nZVswXSA9IChyYW5nZVswXSAtIHBlcmNlbnRQb2ludCkgKiBzY2FsZSArIHBlcmNlbnRQb2ludDtcbiAgICByYW5nZVsxXSA9IChyYW5nZVsxXSAtIHBlcmNlbnRQb2ludCkgKiBzY2FsZSArIHBlcmNlbnRQb2ludDsgLy8gUmVzdHJpY3QgcmFuZ2UuXG5cbiAgICB2YXIgbWluTWF4U3BhbiA9IHRoaXMuZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKS5nZXRNaW5NYXhTcGFuKCk7XG4gICAgc2xpZGVyTW92ZSgwLCByYW5nZSwgWzAsIDEwMF0sIDAsIG1pbk1heFNwYW4ubWluU3BhbiwgbWluTWF4U3Bhbi5tYXhTcGFuKTtcbiAgICB0aGlzLl9yYW5nZSA9IHJhbmdlO1xuXG4gICAgaWYgKGxhc3RSYW5nZVswXSAhPT0gcmFuZ2VbMF0gfHwgbGFzdFJhbmdlWzFdICE9PSByYW5nZVsxXSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlld31cbiAgICovXG4gIHBhbjogbWFrZU1vdmVyKGZ1bmN0aW9uIChyYW5nZSwgYXhpc01vZGVsLCBjb29yZEluZm8sIGNvb3JkU3lzTmFtZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c05hbWVdKFtlLm9sZFgsIGUub2xkWV0sIFtlLm5ld1gsIGUubmV3WV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKTtcbiAgICByZXR1cm4gZGlyZWN0aW9uSW5mby5zaWduYWwgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBkaXJlY3Rpb25JbmZvLnBpeGVsIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIEB0aGlzIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbVZpZXd9XG4gICAqL1xuICBzY3JvbGxNb3ZlOiBtYWtlTW92ZXIoZnVuY3Rpb24gKHJhbmdlLCBheGlzTW9kZWwsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBlKSB7XG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0oWzAsIDBdLCBbZS5zY3JvbGxEZWx0YSwgZS5zY3JvbGxEZWx0YV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKTtcbiAgICByZXR1cm4gZGlyZWN0aW9uSW5mby5zaWduYWwgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBlLnNjcm9sbERlbHRhO1xuICB9KVxufTtcblxuZnVuY3Rpb24gbWFrZU1vdmVyKGdldFBlcmNlbnREZWx0YSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBlKSB7XG4gICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciByYW5nZSA9IGxhc3RSYW5nZS5zbGljZSgpOyAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuXG4gICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkSW5mby5heGlzTW9kZWxzWzBdO1xuXG4gICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudERlbHRhID0gZ2V0UGVyY2VudERlbHRhKHJhbmdlLCBheGlzTW9kZWwsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBlKTtcbiAgICBzbGlkZXJNb3ZlKHBlcmNlbnREZWx0YSwgcmFuZ2UsIFswLCAxMDBdLCAnYWxsJyk7XG4gICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcblxuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBnZXREaXJlY3Rpb25JbmZvID0ge1xuICBncmlkOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciByZWN0ID0gY29vcmRJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMuZGltID09PSAneCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBheGlzLmRpbSA9PT0gJ3knXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHBvbGFyID0gY29vcmRJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBwb2xhci5nZXRBbmdsZUF4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICBvbGRQb2ludCA9IG9sZFBvaW50ID8gcG9sYXIucG9pbnRUb0Nvb3JkKG9sZFBvaW50KSA6IFswLCAwXTtcbiAgICBuZXdQb2ludCA9IHBvbGFyLnBvaW50VG9Db29yZChuZXdQb2ludCk7XG5cbiAgICBpZiAoYXhpc01vZGVsLm1haW5UeXBlID09PSAncmFkaXVzQXhpcycpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07IC8vIHJldC5waXhlbExlbmd0aCA9IE1hdGguYWJzKHJhZGl1c0V4dGVudFsxXSAtIHJhZGl1c0V4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKHJhZGl1c0V4dGVudFswXSwgcmFkaXVzRXh0ZW50WzFdKTtcblxuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnYW5nbGVBeGlzJ1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTsgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMoYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKGFuZ2xlRXh0ZW50WzBdLCBhbmdsZUV4dGVudFsxXSk7XG5cbiAgICAgIHJldC5waXhlbExlbmd0aCA9IGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQucGl4ZWxTdGFydCA9IGFuZ2xlRXh0ZW50WzBdO1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAndmVydGljYWwnXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEluc2lkZVpvb21WaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n\n    /* eslint-disable */\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n\n    /* eslint-enable */\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21Nb2RlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbU1vZGVsLmpzPzM3OTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZShcIi4vRGF0YVpvb21Nb2RlbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIFNsaWRlclpvb21Nb2RlbCA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLnNsaWRlcicsXG4gIGxheW91dE1vZGU6ICdib3gnLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyBwaCA9PiBwbGFjZWhvbGRlci4gVXNpbmcgcGxhY2Vob2RlciBoZXJlIGJlY2F1c2VcbiAgICAvLyBkZWF1bHQgdmFsdWUgY2FuIG9ubHkgYmUgZHJpdmVkIGluIHZpZXcgc3RhZ2UuXG4gICAgcmlnaHQ6ICdwaCcsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgdG9wOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIHdpZHRoOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGhlaWdodDogJ3BoJyxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBsZWZ0OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGJvdHRvbTogbnVsbCxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDApJyxcbiAgICAvLyBCYWNrZ3JvdW5kIG9mIHNsaWRlciB6b29tIGNvbXBvbmVudC5cbiAgICAvLyBkYXRhQmFja2dyb3VuZENvbG9yOiAnI2RkZCcsICAgICAgICAgLy8gQmFja2dyb3VuZCBjb29yIG9mIGRhdGEgc2hhZG93IGFuZCBib3JkZXIgb2YgYm94LFxuICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHksIHJlbWFpbiBmb3IgY29tcGF0aWJpbGl0eSBvZlxuICAgIC8vIHByZXZpb3VzIHZlcnNpb24sIGJ1dCBub3QgcmVjb21tZW5kZWQgYW55IG1vcmUuXG4gICAgZGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMyZjQ1NTQnLFxuICAgICAgICB3aWR0aDogMC41LFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH0sXG4gICAgICBhcmVhU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDAuMyknLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvcmRlckNvbG9yOiAnI2RkZCcsXG4gICAgLy8gYm9yZGVyIGNvbG9yIG9mIHRoZSBib3guIEZvciBjb21wYXRpYmlsaXR5LFxuICAgIC8vIGlmIGRhdGFCYWNrZ3JvdW5kQ29sb3IgaXMgc2V0LCBib3JkZXJDb2xvclxuICAgIC8vIGlzIGlnbm9yZWQuXG4gICAgZmlsbGVyQ29sb3I6ICdyZ2JhKDE2NywxODMsMjA0LDAuNCknLFxuICAgIC8vIENvbG9yIG9mIHNlbGVjdGVkIGFyZWEuXG4gICAgLy8gaGFuZGxlQ29sb3I6ICdyZ2JhKDg5LDE3MCwyMTYsMC45NSknLCAgICAgLy8gQ29sb3Igb2YgaGFuZGxlLlxuICAgIC8vIGhhbmRsZUljb246ICdwYXRoOi8vTTQuOSwxNy44YzAtMS40LDQuNS0xMC41LDUuNS0xMi40YzAtMC4xLDAuNi0xLjEsMC45LTEuMWMwLjQsMCwwLjksMSwwLjksMS4xYzEuMSwyLjIsNS40LDExLDUuNCwxMi40djE3LjhjMCwxLjUtMC42LDIuMS0xLjMsMi4xSDYuMWMtMC43LDAtMS4zLTAuNi0xLjMtMi4xVjE3Ljh6JyxcblxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgaGFuZGxlSWNvbjogJ004LjIsMTMuNlYzLjlINi4zdjkuN0gzLjF2MTQuOWgzLjN2OS43aDEuOHYtOS43aDMuM1YxMy42SDguMnogTTkuNywyNC40SDQuOHYtMS40aDQuOVYyNC40eiBNOS43LDE5LjFINC44di0xLjRoNC45VjE5LjF6JyxcblxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAvLyBQZXJjZW50IG9mIHRoZSBzbGlkZXIgaGVpZ2h0XG4gICAgaGFuZGxlU2l6ZTogJzEwMCUnLFxuICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNhN2I3Y2MnXG4gICAgfSxcbiAgICBsYWJlbFByZWNpc2lvbjogbnVsbCxcbiAgICBsYWJlbEZvcm1hdHRlcjogbnVsbCxcbiAgICBzaG93RGV0YWlsOiB0cnVlLFxuICAgIHNob3dEYXRhU2hhZG93OiAnYXV0bycsXG4gICAgLy8gRGVmYXVsdCBhdXRvIGRlY2lzaW9uLlxuICAgIHJlYWx0aW1lOiB0cnVlLFxuICAgIHpvb21Mb2NrOiBmYWxzZSxcbiAgICAvLyBXaGV0aGVyIGRpc2FibGUgem9vbS5cbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzMzMydcbiAgICB9XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gU2xpZGVyWm9vbU1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar eventTool = __webpack_require__(/*! zrender/lib/core/event */ \"./node_modules/zrender/lib/core/event.js\");\n\nvar graphic = __webpack_require__(/*! ../../util/graphic */ \"./node_modules/echarts/lib/util/graphic.js\");\n\nvar throttle = __webpack_require__(/*! ../../util/throttle */ \"./node_modules/echarts/lib/util/throttle.js\");\n\nvar DataZoomView = __webpack_require__(/*! ./DataZoomView */ \"./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\");\n\nvar numberUtil = __webpack_require__(/*! ../../util/number */ \"./node_modules/echarts/lib/util/number.js\");\n\nvar layout = __webpack_require__(/*! ../../util/layout */ \"./node_modules/echarts/lib/util/layout.js\");\n\nvar sliderMove = __webpack_require__(/*! ../helper/sliderMove */ \"./node_modules/echarts/lib/component/helper/sliderMove.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // list\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   * @return {boolean} changed\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    var lastRange = this._range;\n    var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // dateformatterautoformatterec2 date.getAutoFormatter\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    var changed = this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime); // Avoid dispatch dataZoom repeatly but range not changed,\n    // which cause bad visual effect when progressive enabled.\n\n\n    changed && realtime && this._dispatchZoomAction();\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    var changed = this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    changed && this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // getOtherAxis\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21WaWV3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qcz8yMzI1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciB0aHJvdHRsZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3Rocm90dGxlXCIpO1xuXG52YXIgRGF0YVpvb21WaWV3ID0gcmVxdWlyZShcIi4vRGF0YVpvb21WaWV3XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGxheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7IC8vIENvbnN0YW50c1xuXG52YXIgREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCA9IDc7XG52YXIgREVGQVVMVF9GUkFNRV9CT1JERVJfV0lEVEggPSAxO1xudmFyIERFRkFVTFRfRklMTEVSX1NJWkUgPSAzMDtcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbnZhciBMQUJFTF9HQVAgPSA1O1xudmFyIFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUgPSBbJ2xpbmUnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInXTtcbnZhciBTbGlkZXJab29tVmlldyA9IERhdGFab29tVmlldy5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uc2xpZGVyJyxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLl9vcmllbnQ7XG4gICAgLyoqXG4gICAgICogWzAsIDEwMF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2U7XG4gICAgLyoqXG4gICAgICogW2Nvb3JkIG9mIHRoZSBmaXJzdCBoYW5kbGUsIGNvb3JkIG9mIHRoZSBzZWNvbmQgaGFuZGxlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIC8qKlxuICAgICAqIFtsZW5ndGgsIHRoaWNrXVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuXG4gICAgdGhpcy5fc2l6ZTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2xvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9kcmFnZ2luZztcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fZGF0YVNoYWRvd0luZm87XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZSh0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicsIHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Rocm90dGxlJyksICdmaXhSYXRlJyk7XG4gICAgdGhpcy5fb3JpZW50ID0gZGF0YVpvb21Nb2RlbC5nZXQoJ29yaWVudCcpO1xuXG4gICAgaWYgKHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3cnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBOb3RpY2U6IHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKSBzaG91bGQgbm90IGJlIGV4ZWN1dGVkIHdoZW4gcGF5bG9hZC50eXBlXG4gICAgLy8gaXMgJ2RhdGFab29tJywgb3JpZ2luIHRoaXMuX3JhbmdlIHNob3VsZCBiZSBtYWludGFpbmVkLCBvdGhlcndpc2UgJ3BhbidcbiAgICAvLyBvciAnem9vbScgaW5mbyB3aWxsIGJlIG1pc3NlZCBiZWNhdXNlIG9mICd0aHJvdHRsZScgb2YgdGhpcy5kaXNwYXRjaEFjdGlvbixcblxuXG4gICAgaWYgKCFwYXlsb2FkIHx8IHBheWxvYWQudHlwZSAhPT0gJ2RhdGFab29tJyB8fCBwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9idWlsZFZpZXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBTbGlkZXJab29tVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuICBfYnVpbGRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fcmVzZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fcmVzZXRJbnRlcnZhbCgpO1xuXG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlckhhbmRsZSgpO1xuXG4gICAgdGhpcy5fcmVuZGVyRGF0YVNoYWRvdygpO1xuXG4gICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG5cbiAgICB0aGlzLl9wb3NpdGlvbkdyb3VwKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLmFwaTsgLy8gSWYgc29tZSBvZiB4L3kvd2lkdGgvaGVpZ2h0IGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIGF1dG8tYWRhcHQgYWNjb3JkaW5nIHRvIHRhcmdldCBncmlkLlxuXG4gICAgdmFyIGNvb3JkUmVjdCA9IHRoaXMuX2ZpbmRDb29yZFJlY3QoKTtcblxuICAgIHZhciBlY1NpemUgPSB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH07IC8vIERlZmF1bHQgYWxpZ24gYnkgY29vcmRpbmF0ZSBzeXN0ZW0gcmVjdC5cblxuICAgIHZhciBwb3NpdGlvbkluZm8gPSB0aGlzLl9vcmllbnQgPT09IEhPUklaT05UQUwgPyB7XG4gICAgICAvLyBXaHkgdXNpbmcgJ3JpZ2h0JywgYmVjYXVzZSByaWdodCBzaG91bGQgYmUgdXNlZCBpbiB2ZXJ0aWNhbCxcbiAgICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgY29uc2lzdGVudCBmb3IgZGVhbGluZyB3aXRoIHBvc2l0aW9uIHBhcmFtIG1lcmdlLlxuICAgICAgcmlnaHQ6IGVjU2l6ZS53aWR0aCAtIGNvb3JkUmVjdC54IC0gY29vcmRSZWN0LndpZHRoLFxuICAgICAgdG9wOiBlY1NpemUuaGVpZ2h0IC0gREVGQVVMVF9GSUxMRVJfU0laRSAtIERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAsXG4gICAgICB3aWR0aDogY29vcmRSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBERUZBVUxUX0ZJTExFUl9TSVpFXG4gICAgfSA6IHtcbiAgICAgIC8vIHZlcnRpY2FsXG4gICAgICByaWdodDogREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCxcbiAgICAgIHRvcDogY29vcmRSZWN0LnksXG4gICAgICB3aWR0aDogREVGQVVMVF9GSUxMRVJfU0laRSxcbiAgICAgIGhlaWdodDogY29vcmRSZWN0LmhlaWdodFxuICAgIH07IC8vIERvIG5vdCB3cml0ZSBiYWNrIHRvIG9wdGlvbiBhbmQgcmVwbGFjZSB2YWx1ZSAncGgnLCBiZWNhdXNlXG4gICAgLy8gdGhlICdwaCcgdmFsdWUgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHJlc2l6ZS5cblxuICAgIHZhciBsYXlvdXRQYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKGRhdGFab29tTW9kZWwub3B0aW9uKTsgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG5cbiAgICB6clV0aWwuZWFjaChbJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChsYXlvdXRQYXJhbXNbbmFtZV0gPT09ICdwaCcpIHtcbiAgICAgICAgbGF5b3V0UGFyYW1zW25hbWVdID0gcG9zaXRpb25JbmZvW25hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QobGF5b3V0UGFyYW1zLCBlY1NpemUsIGRhdGFab29tTW9kZWwucGFkZGluZyk7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB7XG4gICAgICB4OiBsYXlvdXRSZWN0LngsXG4gICAgICB5OiBsYXlvdXRSZWN0LnlcbiAgICB9O1xuICAgIHRoaXMuX3NpemUgPSBbbGF5b3V0UmVjdC53aWR0aCwgbGF5b3V0UmVjdC5oZWlnaHRdO1xuICAgIHRoaXMuX29yaWVudCA9PT0gVkVSVElDQUwgJiYgdGhpcy5fc2l6ZS5yZXZlcnNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9zaXRpb25Hcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9uO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7IC8vIEp1c3QgdXNlIHRoZSBmaXJzdCBheGlzIHRvIGRldGVybWluZSBtYXBwaW5nLlxuXG4gICAgdmFyIHRhcmdldEF4aXNNb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRGaXJzdFRhcmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpbnZlcnNlID0gdGFyZ2V0QXhpc01vZGVsICYmIHRhcmdldEF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXA7XG4gICAgdmFyIG90aGVyQXhpc0ludmVyc2UgPSAodGhpcy5fZGF0YVNoYWRvd0luZm8gfHwge30pLm90aGVyQXhpc0ludmVyc2U7IC8vIFRyYW5zZm9ybSBiYXJHcm91cC5cblxuICAgIGJhckdyb3VwLmF0dHIob3JpZW50ID09PSBIT1JJWk9OVEFMICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbMSwgMV0gOiBbMSwgLTFdXG4gICAgfSA6IG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiBpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbLTEsIDFdIDogWy0xLCAtMV1cbiAgICB9IDogb3JpZW50ID09PSBWRVJUSUNBTCAmJiAhaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWzEsIC0xXSA6IFsxLCAxXSxcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMiAvLyBEb250IHVzZSBNYXRoLlBJLCBjb25zaWRlcmluZyBzaGFkb3cgZGlyZWN0aW9uLlxuXG4gICAgfSA6IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWy0xLCAtMV0gOiBbLTEsIDFdLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfSk7IC8vIFBvc2l0aW9uIGJhckdyb3VwXG5cbiAgICB2YXIgcmVjdCA9IHRoaXNHcm91cC5nZXRCb3VuZGluZ1JlY3QoW2Jhckdyb3VwXSk7XG4gICAgdGhpc0dyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xvY2F0aW9uLnggLSByZWN0LngsIGxvY2F0aW9uLnkgLSByZWN0LnldKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRWaWV3RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswLCB0aGlzLl9zaXplWzBdXTtcbiAgfSxcbiAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICB9LFxuICAgICAgejI6IC00MFxuICAgIH0pKTsgLy8gQ2xpY2sgcGFuZWwsIG92ZXIgc2hhZG93LCBiZWxvdyBoYW5kbGVzLlxuXG4gICAgYmFyR3JvdXAuYWRkKG5ldyBSZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgejI6IDAsXG4gICAgICBvbmNsaWNrOiB6clV0aWwuYmluZCh0aGlzLl9vbkNsaWNrUGFuZWxDbGljaywgdGhpcylcbiAgICB9KSk7XG4gIH0sXG4gIF9yZW5kZXJEYXRhU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLl9kYXRhU2hhZG93SW5mbyA9IHRoaXMuX3ByZXBhcmVEYXRhU2hhZG93SW5mbygpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGluZm8uc2VyaWVzO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSA/IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSgpIC8vIEBzZWUgY2FuZGxlc3RpY2tcbiAgICA6IGluZm8ub3RoZXJEaW07XG5cbiAgICBpZiAob3RoZXJEaW0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdGhlckRhdGFFeHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQob3RoZXJEaW0pOyAvLyBOaWNlIGV4dGVudC5cblxuICAgIHZhciBvdGhlck9mZnNldCA9IChvdGhlckRhdGFFeHRlbnRbMV0gLSBvdGhlckRhdGFFeHRlbnRbMF0pICogMC4zO1xuICAgIG90aGVyRGF0YUV4dGVudCA9IFtvdGhlckRhdGFFeHRlbnRbMF0gLSBvdGhlck9mZnNldCwgb3RoZXJEYXRhRXh0ZW50WzFdICsgb3RoZXJPZmZzZXRdO1xuICAgIHZhciBvdGhlclNoYWRvd0V4dGVudCA9IFswLCBzaXplWzFdXTtcbiAgICB2YXIgdGhpc1NoYWRvd0V4dGVudCA9IFswLCBzaXplWzBdXTtcbiAgICB2YXIgYXJlYVBvaW50cyA9IFtbc2l6ZVswXSwgMF0sIFswLCAwXV07XG4gICAgdmFyIGxpbmVQb2ludHMgPSBbXTtcbiAgICB2YXIgc3RlcCA9IHRoaXNTaGFkb3dFeHRlbnRbMV0gLyAoZGF0YS5jb3VudCgpIC0gMSk7XG4gICAgdmFyIHRoaXNDb29yZCA9IDA7IC8vIE9wdGltaXplIGZvciBsYXJnZSBkYXRhIHNoYWRvd1xuXG4gICAgdmFyIHN0cmlkZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZVswXSk7XG4gICAgdmFyIGxhc3RJc0VtcHR5O1xuICAgIGRhdGEuZWFjaChbb3RoZXJEaW1dLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoc3RyaWRlID4gMCAmJiBpbmRleCAlIHN0cmlkZSkge1xuICAgICAgICB0aGlzQ29vcmQgKz0gc3RlcDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGSVhNRVxuICAgICAgLy8gU2hvdWxkIGNvbnNpZGVyIGF4aXMubWluL2F4aXMubWF4IHdoZW4gZHJhd2luZyBkYXRhU2hhZG93LlxuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIOW6lOivpeS9v+eUqOe7n+S4gOeahOepuuWIpOaWre+8n+i/mOaYr+WcqGxpc3Tph4zov5vooYznqbrliKTmlq3vvJ9cblxuXG4gICAgICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAnJzsgLy8gU2VlICM0MjM1LlxuXG4gICAgICB2YXIgb3RoZXJDb29yZCA9IGlzRW1wdHkgPyAwIDogbGluZWFyTWFwKHZhbHVlLCBvdGhlckRhdGFFeHRlbnQsIG90aGVyU2hhZG93RXh0ZW50LCB0cnVlKTsgLy8gQXR0ZW1wdCB0byBkcmF3IGRhdGEgc2hhZG93IHByZWNpc2VseSB3aGVuIHRoZXJlIGFyZSBlbXB0eSB2YWx1ZS5cblxuICAgICAgaWYgKGlzRW1wdHkgJiYgIWxhc3RJc0VtcHR5ICYmIGluZGV4KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbYXJlYVBvaW50c1thcmVhUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbbGluZVBvaW50c1tsaW5lUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5ICYmIGxhc3RJc0VtcHR5KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICB9XG5cbiAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCBvdGhlckNvb3JkXSk7XG4gICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICBsYXN0SXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgfSk7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7IC8vIHZhciBkYXRhQmFja2dyb3VuZE1vZGVsID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQnKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IGFyZWFQb2ludHNcbiAgICAgIH0sXG4gICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2RhdGFCYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgfSwgZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQuYXJlYVN0eWxlJykuZ2V0QXJlYVN0eWxlKCkpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0yMFxuICAgIH0pKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBsaW5lUG9pbnRzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0xOVxuICAgIH0pKTtcbiAgfSxcbiAgX3ByZXBhcmVEYXRhU2hhZG93SW5mbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBzaG93RGF0YVNoYWRvdyA9IGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGF0YVNoYWRvdycpO1xuXG4gICAgaWYgKHNob3dEYXRhU2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHJlcHJlc2VudGF0aXZlIHNlcmllcy5cblxuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzTW9kZWxzID0gZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICAgIHpyVXRpbC5lYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd0RhdGFTaGFkb3cgIT09IHRydWUgJiYgenJVdGlsLmluZGV4T2YoU0hPV19EQVRBX1NIQURPV19TRVJJRVNfVFlQRSwgc2VyaWVzTW9kZWwuZ2V0KCd0eXBlJykpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXhpcyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCkuYXhpcztcbiAgICAgICAgdmFyIG90aGVyRGltID0gZ2V0T3RoZXJEaW0oZGltTmFtZXMubmFtZSk7XG4gICAgICAgIHZhciBvdGhlckF4aXNJbnZlcnNlO1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgIGlmIChvdGhlckRpbSAhPSBudWxsICYmIGNvb3JkU3lzLmdldE90aGVyQXhpcykge1xuICAgICAgICAgIG90aGVyQXhpc0ludmVyc2UgPSBjb29yZFN5cy5nZXRPdGhlckF4aXModGhpc0F4aXMpLmludmVyc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24ob3RoZXJEaW0pO1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgdGhpc0F4aXM6IHRoaXNBeGlzLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWwsXG4gICAgICAgICAgdGhpc0RpbTogZGltTmFtZXMubmFtZSxcbiAgICAgICAgICBvdGhlckRpbTogb3RoZXJEaW0sXG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZTogb3RoZXJBeGlzSW52ZXJzZVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlcyA9IGRpc3BsYXlibGVzLmhhbmRsZXMgPSBbXTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzID0gW107XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICBiYXJHcm91cC5hZGQoZGlzcGxheWJsZXMuZmlsbGVyID0gbmV3IFJlY3Qoe1xuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uRHJhZ01vdmUsIHRoaXMsICdhbGwnKSxcbiAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbmRyYWdzdGFydDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdmaWxsZXJDb2xvcicpLFxuICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnXG4gICAgICB9XG4gICAgfSkpOyAvLyBGcmFtZSBib3JkZXIuXG5cbiAgICBiYXJHcm91cC5hZGQobmV3IFJlY3QoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiBkYXRhWm9vbU1vZGVsLmdldCgnZGF0YUJhY2tncm91bmRDb2xvcicpIHx8IGRhdGFab29tTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRILFxuICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgIH1cbiAgICB9KSkpO1xuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5jcmVhdGVJY29uKGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyksIHtcbiAgICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkRyYWdNb3ZlLCB0aGlzLCBoYW5kbGVJbmRleCksXG4gICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkRyYWdFbmQsIHRoaXMpLFxuICAgICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgICBvbm1vdXNlb3V0OiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgZmFsc2UpXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgaGVpZ2h0OiAyXG4gICAgICB9KTtcbiAgICAgIHZhciBiUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB0aGlzLl9oYW5kbGVIZWlnaHQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChkYXRhWm9vbU1vZGVsLmdldCgnaGFuZGxlU2l6ZScpLCB0aGlzLl9zaXplWzFdKTtcbiAgICAgIHRoaXMuX2hhbmRsZVdpZHRoID0gYlJlY3Qud2lkdGggLyBiUmVjdC5oZWlnaHQgKiB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgICBwYXRoLnNldFN0eWxlKGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgdmFyIGhhbmRsZUNvbG9yID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZUNvbG9yJyk7IC8vIENvbXBhdGl0YWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb25cblxuICAgICAgaWYgKGhhbmRsZUNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgcGF0aC5zdHlsZS5maWxsID0gaGFuZGxlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGJhckdyb3VwLmFkZChoYW5kbGVzW2hhbmRsZUluZGV4XSA9IHBhdGgpO1xuICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gZGF0YVpvb21Nb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0gPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpXG4gICAgICAgIH0sXG4gICAgICAgIHoyOiAxMFxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcblxuICAgIHZhciB2aWV3RXh0ZW50ID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuXG4gICAgdGhpcy5faGFuZGxlRW5kcyA9IFtsaW5lYXJNYXAocmFuZ2VbMF0sIFswLCAxMDBdLCB2aWV3RXh0ZW50LCB0cnVlKSwgbGluZWFyTWFwKHJhbmdlWzFdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaGFuZGxlSW5kZXggMCBvciAxIG9yICdhbGwnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBfdXBkYXRlSW50ZXJ2YWw6IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgZGVsdGEpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG5cbiAgICB2YXIgdmlld0V4dGVuZCA9IHRoaXMuX2dldFZpZXdFeHRlbnQoKTtcblxuICAgIHZhciBtaW5NYXhTcGFuID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKS5nZXRNaW5NYXhTcGFuKCk7XG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICBzbGlkZXJNb3ZlKGRlbHRhLCBoYW5kbGVFbmRzLCB2aWV3RXh0ZW5kLCBkYXRhWm9vbU1vZGVsLmdldCgnem9vbUxvY2snKSA/ICdhbGwnIDogaGFuZGxlSW5kZXgsIG1pbk1heFNwYW4ubWluU3BhbiAhPSBudWxsID8gbGluZWFyTWFwKG1pbk1heFNwYW4ubWluU3BhbiwgcGVyY2VudEV4dGVudCwgdmlld0V4dGVuZCwgdHJ1ZSkgOiBudWxsLCBtaW5NYXhTcGFuLm1heFNwYW4gIT0gbnVsbCA/IGxpbmVhck1hcChtaW5NYXhTcGFuLm1heFNwYW4sIHBlcmNlbnRFeHRlbnQsIHZpZXdFeHRlbmQsIHRydWUpIDogbnVsbCk7XG4gICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlID0gYXNjKFtsaW5lYXJNYXAoaGFuZGxlRW5kc1swXSwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChoYW5kbGVFbmRzWzFdLCB2aWV3RXh0ZW5kLCBwZXJjZW50RXh0ZW50LCB0cnVlKV0pO1xuICAgIHJldHVybiAhbGFzdFJhbmdlIHx8IGxhc3RSYW5nZVswXSAhPT0gcmFuZ2VbMF0gfHwgbGFzdFJhbmdlWzFdICE9PSByYW5nZVsxXTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVWaWV3OiBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBoYW5kbGVJbnRlcnZhbCA9IGFzYyhoYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBIYW5kbGVzXG4gICAgICB2YXIgaGFuZGxlID0gZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF07XG4gICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgaGFuZGxlLmF0dHIoe1xuICAgICAgICBzY2FsZTogW2hhbmRsZUhlaWdodCAvIDIsIGhhbmRsZUhlaWdodCAvIDJdLFxuICAgICAgICBwb3NpdGlvbjogW2hhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCBzaXplWzFdIC8gMiAtIGhhbmRsZUhlaWdodCAvIDJdXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTsgLy8gRmlsbGVyXG5cbiAgICBkaXNwbGF5Ymxlcy5maWxsZXIuc2V0U2hhcGUoe1xuICAgICAgeDogaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGhhbmRsZUludGVydmFsWzFdIC0gaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZURhdGFJbmZvKG5vblJlYWx0aW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVEYXRhSW5mbzogZnVuY3Rpb24gKG5vblJlYWx0aW1lKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGRpc3BsYXlibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgIHZhciBoYW5kbGVMYWJlbHMgPSBkaXNwbGF5Ymxlcy5oYW5kbGVMYWJlbHM7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDtcbiAgICB2YXIgbGFiZWxUZXh0cyA9IFsnJywgJyddOyAvLyBGSVhNRVxuICAgIC8vIGRhdGXlnovvvIzmlK/mjIFmb3JtYXR0ZXLvvIxhdXRvZm9ybWF0dGVy77yIZWMyIGRhdGUuZ2V0QXV0b0Zvcm1hdHRlcu+8iVxuXG4gICAgaWYgKGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGV0YWlsJykpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXM7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICB2YXIgZGF0YUludGVydmFsID0gbm9uUmVhbHRpbWUgLy8gU2VlICM0NDM0LCBkYXRhIGFuZCBheGlzIGFyZSBub3QgcHJvY2Vzc2VkIGFuZCByZXNldCB5ZXQgaW4gbm9uLXJlYWx0aW1lIG1vZGUuXG4gICAgICAgID8gYXhpc1Byb3h5LmNhbGN1bGF0ZURhdGFXaW5kb3coe1xuICAgICAgICAgIHN0YXJ0OiByYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgICAgIH0pLnZhbHVlV2luZG93IDogYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBsYWJlbFRleHRzID0gW3RoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFswXSwgYXhpcyksIHRoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFsxXSwgYXhpcyldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcmRlcmVkSGFuZGxlRW5kcyA9IGFzYyh0aGlzLl9oYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHNldExhYmVsLmNhbGwodGhpcywgMCk7XG4gICAgc2V0TGFiZWwuY2FsbCh0aGlzLCAxKTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBMYWJlbFxuICAgICAgLy8gVGV4dCBzaG91bGQgbm90IHRyYW5zZm9ybSBieSBiYXJHcm91cC5cbiAgICAgIC8vIElnbm9yZSBoYW5kbGVycyB0cmFuc2Zvcm1cbiAgICAgIHZhciBiYXJUcmFuc2Zvcm0gPSBncmFwaGljLmdldFRyYW5zZm9ybShkaXNwbGF5Ymxlcy5oYW5kbGVzW2hhbmRsZUluZGV4XS5wYXJlbnQsIHRoaXMuZ3JvdXApO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uKGhhbmRsZUluZGV4ID09PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0JywgYmFyVHJhbnNmb3JtKTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9oYW5kbGVXaWR0aCAvIDIgKyBMQUJFTF9HQVA7XG4gICAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbb3JkZXJlZEhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgKGhhbmRsZUluZGV4ID09PSAwID8gLW9mZnNldCA6IG9mZnNldCksIHRoaXMuX3NpemVbMV0gLyAyXSwgYmFyVHJhbnNmb3JtKTtcbiAgICAgIGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0uc2V0U3R5bGUoe1xuICAgICAgICB4OiB0ZXh0UG9pbnRbMF0sXG4gICAgICAgIHk6IHRleHRQb2ludFsxXSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/ICdtaWRkbGUnIDogZGlyZWN0aW9uLFxuICAgICAgICB0ZXh0QWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/IGRpcmVjdGlvbiA6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0OiBsYWJlbFRleHRzW2hhbmRsZUluZGV4XVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Zvcm1hdExhYmVsOiBmdW5jdGlvbiAodmFsdWUsIGF4aXMpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxGb3JtYXR0ZXInKTtcbiAgICB2YXIgbGFiZWxQcmVjaXNpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxQcmVjaXNpb24nKTtcblxuICAgIGlmIChsYWJlbFByZWNpc2lvbiA9PSBudWxsIHx8IGxhYmVsUHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgIGxhYmVsUHJlY2lzaW9uID0gYXhpcy5nZXRQaXhlbFByZWNpc2lvbigpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVN0ciA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gJycgLy8gRklYTUUgR2x1ZSBjb2RlXG4gICAgOiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScgPyBheGlzLnNjYWxlLmdldExhYmVsKE1hdGgucm91bmQodmFsdWUpKSAvLyBwYXJhbSBvZiB0b0ZpeGVkIHNob3VsZCBsZXNzIHRoZW4gMjAuXG4gICAgOiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKGxhYmVsUHJlY2lzaW9uLCAyMCkpO1xuICAgIHJldHVybiB6clV0aWwuaXNGdW5jdGlvbihsYWJlbEZvcm1hdHRlcikgPyBsYWJlbEZvcm1hdHRlcih2YWx1ZSwgdmFsdWVTdHIpIDogenJVdGlsLmlzU3RyaW5nKGxhYmVsRm9ybWF0dGVyKSA/IGxhYmVsRm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB2YWx1ZVN0cikgOiB2YWx1ZVN0cjtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93T3JIaWRlIHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG4gICAqL1xuICBfc2hvd0RhdGFJbmZvOiBmdW5jdGlvbiAoc2hvd09ySGlkZSkge1xuICAgIC8vIEFsd2F5cyBzaG93IHdoZW4gZHJnZ2luZy5cbiAgICBzaG93T3JIaWRlID0gdGhpcy5fZHJhZ2dpbmcgfHwgc2hvd09ySGlkZTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gdGhpcy5fZGlzcGxheWFibGVzLmhhbmRsZUxhYmVscztcbiAgICBoYW5kbGVMYWJlbHNbMF0uYXR0cignaW52aXNpYmxlJywgIXNob3dPckhpZGUpO1xuICAgIGhhbmRsZUxhYmVsc1sxXS5hdHRyKCdpbnZpc2libGUnLCAhc2hvd09ySGlkZSk7XG4gIH0sXG4gIF9vbkRyYWdNb3ZlOiBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGR4LCBkeSkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gVHJhbnNmb3JtIGR4LCBkeSB0byBiYXIgY29vcmRpbmF0aW9uLlxuXG4gICAgdmFyIGJhclRyYW5zZm9ybSA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2R4LCBkeV0sIGJhclRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMF0pO1xuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoIXJlYWx0aW1lKTsgLy8gQXZvaWQgZGlzcGF0Y2ggZGF0YVpvb20gcmVwZWF0bHkgYnV0IHJhbmdlIG5vdCBjaGFuZ2VkLFxuICAgIC8vIHdoaWNoIGNhdXNlIGJhZCB2aXN1YWwgZWZmZWN0IHdoZW4gcHJvZ3Jlc3NpdmUgZW5hYmxlZC5cblxuXG4gICAgY2hhbmdlZCAmJiByZWFsdGltZSAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oKTtcbiAgfSxcbiAgX29uRHJhZ0VuZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9zaG93RGF0YUluZm8oZmFsc2UpOyAvLyBXaGlsZSBpbiByZWFsdGltZSBtb2RlIGFuZCBzdHJlYW0gbW9kZSwgZGlzcGF0Y2ggYWN0aW9uIHdoZW5cbiAgICAvLyBkcmFnIGVuZCB3aWxsIGNhdXNlIHRoZSB3aG9sZSB2aWV3IHJlcmVuZGVyLCB3aGljaCBpcyB1bm5lY2Vzc2FyeS5cblxuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcbiAgICAhcmVhbHRpbWUgJiYgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gIH0sXG4gIF9vbkNsaWNrUGFuZWxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cbiAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuXG4gICAgaWYgKGxvY2FsUG9pbnRbMF0gPCAwIHx8IGxvY2FsUG9pbnRbMF0gPiBzaXplWzBdIHx8IGxvY2FsUG9pbnRbMV0gPCAwIHx8IGxvY2FsUG9pbnRbMV0gPiBzaXplWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBjZW50ZXIgPSAoaGFuZGxlRW5kc1swXSArIGhhbmRsZUVuZHNbMV0pIC8gMjtcblxuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fdXBkYXRlSW50ZXJ2YWwoJ2FsbCcsIGxvY2FsUG9pbnRbMF0gLSBjZW50ZXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuXG4gICAgY2hhbmdlZCAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGF0Y2hab29tQWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgZGF0YVpvb21JZDogdGhpcy5kYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgZW5kOiByYW5nZVsxXVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRDb29yZFJlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBGaW5kIHRoZSBncmlkIGNvcmVzcG9uZGluZyB0byB0aGUgZmlyc3QgYXhpcyByZWZlcnJlZCBieSBkYXRhWm9vbS5cbiAgICB2YXIgcmVjdDtcbiAgICBlYWNoKHRoaXMuZ2V0VGFyZ2V0Q29vcmRJbmZvKCksIGZ1bmN0aW9uIChjb29yZEluZm9MaXN0KSB7XG4gICAgICBpZiAoIXJlY3QgJiYgY29vcmRJbmZvTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gY29vcmRJbmZvTGlzdFswXS5tb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICByZWN0ID0gY29vcmRTeXMuZ2V0UmVjdCAmJiBjb29yZFN5cy5nZXRSZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXBpLmdldFdpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICByZWN0ID0ge1xuICAgICAgICB4OiB3aWR0aCAqIDAuMixcbiAgICAgICAgeTogaGVpZ2h0ICogMC4yLFxuICAgICAgICB3aWR0aDogd2lkdGggKiAwLjYsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICogMC42XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0T3RoZXJEaW0odGhpc0RpbSkge1xuICAvLyBGSVhNRVxuICAvLyDov5nkuKrpgLvovpHlkoxnZXRPdGhlckF4aXPph4zkuIDoh7TvvIzkvYbmmK/lhpnlnKjov5nph4zmmK/lkKbkuI3lpb1cbiAgdmFyIG1hcCA9IHtcbiAgICB4OiAneScsXG4gICAgeTogJ3gnLFxuICAgIHJhZGl1czogJ2FuZ2xlJyxcbiAgICBhbmdsZTogJ3JhZGl1cydcbiAgfTtcbiAgcmV0dXJuIG1hcFt0aGlzRGltXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yKG9yaWVudCkge1xuICByZXR1cm4gb3JpZW50ID09PSAndmVydGljYWwnID8gJ25zLXJlc2l6ZScgOiAnZXctcmVzaXplJztcbn1cblxudmFyIF9kZWZhdWx0ID0gU2xpZGVyWm9vbVZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = __webpack_require__(/*! ../../echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar helper = __webpack_require__(/*! ./helper */ \"./node_modules/echarts/lib/component/dataZoom/helper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tQWN0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qcz85ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignZGF0YVpvb20nLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICB2YXIgbGlua2VkTm9kZXNGaW5kZXIgPSBoZWxwZXIuY3JlYXRlTGlua2VkTm9kZXNGaW5kZXIoenJVdGlsLmJpbmQoZWNNb2RlbC5lYWNoQ29tcG9uZW50LCBlY01vZGVsLCAnZGF0YVpvb20nKSwgaGVscGVyLmVhY2hBeGlzRGltLCBmdW5jdGlvbiAobW9kZWwsIGRpbU5hbWVzKSB7XG4gICAgcmV0dXJuIG1vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICB9KTtcbiAgdmFyIGVmZmVjdGVkTW9kZWxzID0gW107XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgIGVmZmVjdGVkTW9kZWxzLnB1c2guYXBwbHkoZWZmZWN0ZWRNb2RlbHMsIGxpbmtlZE5vZGVzRmluZGVyKG1vZGVsKS5ub2Rlcyk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChlZmZlY3RlZE1vZGVscywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGluZGV4KSB7XG4gICAgZGF0YVpvb21Nb2RlbC5zZXRSYXdSYW5nZSh7XG4gICAgICBzdGFydDogcGF5bG9hZC5zdGFydCxcbiAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICBzdGFydFZhbHVlOiBwYXlsb2FkLnN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZTogcGF5bG9hZC5lbmRWYWx1ZVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = __webpack_require__(/*! ../../echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\nvar _util = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerProcessor({\n  // `dataZoomProcessor` will only be performed in needed series. Consider if\n  // there is a line series and a pie series, it is better not to update the\n  // line series if only pie series is needed to be updated.\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);\n        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n          seriesModelMap.set(seriesModel.uid, seriesModel);\n        });\n      });\n    });\n    return seriesModelMap;\n  },\n  modifyOutputEnd: true,\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      var percentRange = axisProxy.getDataPercentWindow();\n      var valueRange = axisProxy.getDataValueWindow();\n      dataZoomModel.setRawRange({\n        start: percentRange[0],\n        end: percentRange[1],\n        startValue: valueRange[0],\n        endValue: valueRange[1]\n      }, true);\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcz8yYzE3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY3JlYXRlSGFzaE1hcCA9IF91dGlsLmNyZWF0ZUhhc2hNYXA7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3Ioe1xuICAvLyBgZGF0YVpvb21Qcm9jZXNzb3JgIHdpbGwgb25seSBiZSBwZXJmb3JtZWQgaW4gbmVlZGVkIHNlcmllcy4gQ29uc2lkZXIgaWZcbiAgLy8gdGhlcmUgaXMgYSBsaW5lIHNlcmllcyBhbmQgYSBwaWUgc2VyaWVzLCBpdCBpcyBiZXR0ZXIgbm90IHRvIHVwZGF0ZSB0aGVcbiAgLy8gbGluZSBzZXJpZXMgaWYgb25seSBwaWUgc2VyaWVzIGlzIG5lZWRlZCB0byBiZSB1cGRhdGVkLlxuICBnZXRUYXJnZXRTZXJpZXM6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIHNlcmllc01vZGVsTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICB2YXIgYXhpc1Byb3h5ID0gZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KTtcbiAgICAgICAgZWFjaChheGlzUHJveHkuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCksIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgIHNlcmllc01vZGVsTWFwLnNldChzZXJpZXNNb2RlbC51aWQsIHNlcmllc01vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWVzTW9kZWxNYXA7XG4gIH0sXG4gIG1vZGlmeU91dHB1dEVuZDogdHJ1ZSxcbiAgLy8gQ29uc2lkZXIgYXBwZW5kRGF0YSwgd2hlcmUgZmlsdGVyIHNob3VsZCBiZSBwZXJmb3JtZWQuIEJlY2F1c2UgZGF0YSBwcm9jZXNzIGlzXG4gIC8vIGluIGJsb2NrIG1vZGUgY3VycmVudGx5LCBpdCBpcyBub3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0IHRoZSBvdmVyYWxsUHJvZ3Jlc3NcbiAgLy8gZXhlY3V0ZSBldmVyeSBmcmFtZS5cbiAgb3ZlcmFsbFJlc2V0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBXZSBjYWxjdWxhdGUgd2luZG93IGFuZCByZXNldCBheGlzIGhlcmUgYnV0IG5vdCBpbiBtb2RlbFxuICAgICAgLy8gaW5pdCBzdGFnZSBhbmQgbm90IGFmdGVyIGFjdGlvbiBkaXNwYXRjaCBoYW5kbGVyLCBiZWNhdXNlXG4gICAgICAvLyByZXNldCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNlcmllc0RhdGEucmVzdG9yZURhdGEuXG4gICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkucmVzZXQoZGF0YVpvb21Nb2RlbCwgYXBpKTtcbiAgICAgIH0pOyAvLyBDYXV0aW9uOiBkYXRhIHpvb20gZmlsdGVyaW5nIGlzIG9yZGVyIHNlbnNpdGl2ZSB3aGVuIHVzaW5nXG4gICAgICAvLyBwZXJjZW50IHJhbmdlIGFuZCBubyBtaW4vbWF4L3NjYWxlIHNldCBvbiBheGlzLlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIHdlIGhhdmUgZGF0YVpvb20gZGVmaW5pdGlvbjpcbiAgICAgIC8vIFtcbiAgICAgIC8vICAgICAge3hBeGlzSW5kZXg6IDAsIHN0YXJ0OiAzMCwgZW5kOiA3MH0sXG4gICAgICAvLyAgICAgIHt5QXhpc0luZGV4OiAwLCBzdGFydDogMjAsIGVuZDogODB9XG4gICAgICAvLyBdXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIFsyMCwgODBdIG9mIHktZGF0YVpvb20gc2hvdWxkIGJlIGJhc2VkIG9uIGRhdGFcbiAgICAgIC8vIHRoYXQgaGF2ZSBmaWx0ZXJlZCBieSB4LWRhdGFab29tIHVzaW5nIHJhbmdlIG9mIFszMCwgNzBdLFxuICAgICAgLy8gYnV0IHNob3VsZCBub3QgYmUgYmFzZWQgb24gZnVsbCByYXcgZGF0YS4gVGh1cyBzbGlkaW5nXG4gICAgICAvLyB4LWRhdGFab29tIHdpbGwgY2hhbmdlIGJvdGggcmFuZ2VzIG9mIHhBeGlzIGFuZCB5QXhpcyxcbiAgICAgIC8vIHdoaWxlIHNsaWRpbmcgeS1kYXRhWm9vbSB3aWxsIG9ubHkgY2hhbmdlIHRoZSByYW5nZSBvZiB5QXhpcy5cbiAgICAgIC8vIFNvIHdlIHNob3VsZCBmaWx0ZXIgeC1heGlzIGFmdGVyIHJlc2V0IHgtYXhpcyBpbW1lZGlhdGVseSxcbiAgICAgIC8vIGFuZCB0aGVuIHJlc2V0IHktYXhpcyBhbmQgZmlsdGVyIHktYXhpcy5cblxuICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpLmZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCwgYXBpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgLy8gRnVsbGZpbGwgYWxsIG9mIHRoZSByYW5nZSBwcm9wcyBzbyB0aGF0IHVzZXJcbiAgICAgIC8vIGlzIGFibGUgdG8gZ2V0IHRoZW0gZnJvbSBjaGFydC5nZXRPcHRpb24oKS5cbiAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgdmFyIHBlcmNlbnRSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgICAgdmFyIHZhbHVlUmFuZ2UgPSBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICBkYXRhWm9vbU1vZGVsLnNldFJhd1JhbmdlKHtcbiAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV0sXG4gICAgICAgIHN0YXJ0VmFsdWU6IHZhbHVlUmFuZ2VbMF0sXG4gICAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgICB9LCB0cnVlKTtcbiAgICB9KTtcbiAgfVxufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/helper.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar formatUtil = __webpack_require__(/*! ../../util/format */ \"./node_modules/echarts/lib/util/format.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzPzUwZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIEFYSVNfRElNUyA9IFsneCcsICd5JywgJ3onLCAncmFkaXVzJywgJ2FuZ2xlJywgJ3NpbmdsZSddOyAvLyBTdXBwb3J0ZWQgY29vcmRzLlxuXG52YXIgQ09PUkRTID0gWydjYXJ0ZXNpYW4yZCcsICdwb2xhcicsICdzaW5nbGVBeGlzJ107XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNDb29yZFN1cHBvcnRlZChjb29yZFR5cGUpIHtcbiAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKENPT1JEUywgY29vcmRUeXBlKSA+PSAwO1xufVxuLyoqXG4gKiBDcmVhdGUgXCJlYWNoXCIgbWV0aG9kIHRvIGl0ZXJhdGUgbmFtZXMuXG4gKlxuICogQHB1YmlsY1xuICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IG5hbWVzXG4gKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPj19IGF0dHJzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVFYWNoKG5hbWVzLCBhdHRycykge1xuICBuYW1lcyA9IG5hbWVzLnNsaWNlKCk7XG4gIHZhciBjYXBpdGFsTmFtZXMgPSB6clV0aWwubWFwKG5hbWVzLCBmb3JtYXRVdGlsLmNhcGl0YWxGaXJzdCk7XG4gIGF0dHJzID0gKGF0dHJzIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgY2FwaXRhbEF0dHJzID0genJVdGlsLm1hcChhdHRycywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgenJVdGlsLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgdmFyIG5hbWVPYmogPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGNhcGl0YWw6IGNhcGl0YWxOYW1lc1tpbmRleF1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbmFtZU9ialthdHRyc1tqXV0gPSBuYW1lICsgY2FwaXRhbEF0dHJzW2pdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG5hbWVPYmopO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBJdGVyYXRlIGVhY2ggZGltZW5zaW9uIG5hbWUuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHBhcmFtZXRlciBpcyBsaWtlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaXRhbDogJ0FuZ2xlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzOiAnYW5nbGVBeGlzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzSW5kZXg6ICdhbmdsZUFpeHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAnYW5nbGVJbmRleCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cblxuXG52YXIgZWFjaEF4aXNEaW0gPSBjcmVhdGVOYW1lRWFjaChBWElTX0RJTVMsIFsnYXhpc0luZGV4JywgJ2F4aXMnLCAnaW5kZXgnLCAnaWQnXSk7XG4vKipcbiAqIElmIHRvdyBkYXRhWm9vbU1vZGVscyBoYXMgdGhlIHNhbWUgYXhpcyBjb250cm9sbGVkLCB3ZSBzYXkgdGhhdCB0aGV5IGFyZSAnbGlua2VkJy5cbiAqIGRhdGFab29tTW9kZWxzIGFuZCAnbGlua3MnIG1ha2UgdXAgb25lIG9yIG1vcmUgZ3JhcGhpY3MuXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBncmFwaGljIHdoZXJlIHRoZSBzb3VyY2UgZGF0YVpvb21Nb2RlbCBpcyBpbi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoTm9kZSBOb2RlIGl0ZXJhdG9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yRWFjaEVkZ2VUeXBlIGVkZ2VUeXBlIGl0ZXJhdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZGdlSWRHZXR0ZXIgR2l2aW5nIG5vZGUgYW5kIGVkZ2VUeXBlLCByZXR1cm4gYW4gYXJyYXkgb2YgZWRnZSBpZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJbnB1dDogc291cmNlTm9kZSwgT3V0cHV0OiBMaWtlIHtub2RlczogW10sIGRpbXM6IHt9fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyKGZvckVhY2hOb2RlLCBmb3JFYWNoRWRnZVR5cGUsIGVkZ2VJZEdldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZU5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbm9kZXM6IFtdLFxuICAgICAgcmVjb3Jkczoge30gLy8ga2V5OiBlZGdlVHlwZS5uYW1lLCB2YWx1ZTogT2JqZWN0IChrZXk6IGVkZ2UgaWQsIHZhbHVlOiBib29sZWFuKS5cblxuICAgIH07XG4gICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV0gPSB7fTtcbiAgICB9KTtcblxuICAgIGlmICghc291cmNlTm9kZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhYnNvcmIoc291cmNlTm9kZSwgcmVzdWx0KTtcbiAgICB2YXIgZXhpc3RzTGluaztcblxuICAgIGRvIHtcbiAgICAgIGV4aXN0c0xpbmsgPSBmYWxzZTtcbiAgICAgIGZvckVhY2hOb2RlKHByb2Nlc3NTaW5nbGVOb2RlKTtcbiAgICB9IHdoaWxlIChleGlzdHNMaW5rKTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTaW5nbGVOb2RlKG5vZGUpIHtcbiAgICAgIGlmICghaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSAmJiBpc0xpbmtlZChub2RlLCByZXN1bHQpKSB7XG4gICAgICAgIGFic29yYihub2RlLCByZXN1bHQpO1xuICAgICAgICBleGlzdHNMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzTm9kZUFic29yZGVkKG5vZGUsIHJlc3VsdCkge1xuICAgIHJldHVybiB6clV0aWwuaW5kZXhPZihyZXN1bHQubm9kZXMsIG5vZGUpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmtlZChub2RlLCByZXN1bHQpIHtcbiAgICB2YXIgaGFzTGluayA9IGZhbHNlO1xuICAgIGZvckVhY2hFZGdlVHlwZShmdW5jdGlvbiAoZWRnZVR5cGUpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSAmJiAoaGFzTGluayA9IHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc0xpbms7XG4gIH1cblxuICBmdW5jdGlvbiBhYnNvcmIobm9kZSwgcmVzdWx0KSB7XG4gICAgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgenJVdGlsLmVhY2goZWRnZUlkR2V0dGVyKG5vZGUsIGVkZ2VUeXBlKSB8fCBbXSwgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXVtlZGdlSWRdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydHMuaXNDb29yZFN1cHBvcnRlZCA9IGlzQ29vcmRTdXBwb3J0ZWQ7XG5leHBvcnRzLmNyZWF0ZU5hbWVFYWNoID0gY3JlYXRlTmFtZUVhY2g7XG5leHBvcnRzLmVhY2hBeGlzRGltID0gZWFjaEF4aXNEaW07XG5leHBvcnRzLmNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyID0gY3JlYXRlTGlua2VkTm9kZXNGaW5kZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/helper.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/roams.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/roams.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar RoamController = __webpack_require__(/*! ../../component/helper/RoamController */ \"./node_modules/echarts/lib/component/helper/RoamController.js\");\n\nvar throttleUtil = __webpack_require__(/*! ../../util/throttle */ \"./node_modules/echarts/lib/util/throttle.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {Object} dataZoomInfo.getRange\n * @param {Function} dataZoomInfo.getRange.pan\n * @param {Function} dataZoomInfo.getRange.zoom\n * @param {Function} dataZoomInfo.getRange.scrollMove\n * @param {boolean} dataZoomInfo.dataZoomModel\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.dataZoomModel.get('throttle', true), 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  zrUtil.each(['pan', 'zoom', 'scrollMove'], function (eventName) {\n    controller.on(eventName, function (event) {\n      var batch = [];\n      zrUtil.each(newRecord.dataZoomInfos, function (info) {\n        // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,\n        // moveOnMouseWheel, ...) enabled.\n        if (!event.isAvailableBehavior(info.dataZoomModel.option)) {\n          return;\n        }\n\n        var method = (info.getRange || {})[eventName];\n        var range = method && method(newRecord.controller, event);\n        !info.dataZoomModel.get('disabled', true) && range && batch.push({\n          dataZoomId: info.dataZoomId,\n          start: range[0],\n          end: range[1]\n        });\n      });\n      batch.length && newRecord.dispatchAction(batch);\n    });\n  });\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  var preventDefaultMouseMove = true;\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var dataZoomModel = dataZoomInfo.dataZoomModel;\n    var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Prevent default move event by default. If one false, do not prevent. Otherwise\n    // users may be confused why it does not work when multiple insideZooms exist.\n\n\n    preventDefaultMouseMove &= dataZoomModel.get('preventDefaultMouseMove', true);\n  });\n  return {\n    controlType: controlType,\n    opt: {\n      // RoamController will enable all of these functionalities,\n      // and the final behavior is determined by its event listener\n      // provided by each inside zoom.\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      moveOnMouseWheel: true,\n      preventDefaultMouseMove: !!preventDefaultMouseMove\n    }\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.generateCoordId = generateCoordId;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9yb2Ftcy5qcz81NTc2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFJvYW1Db250cm9sbGVyID0gcmVxdWlyZShcIi4uLy4uL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcIik7XG5cbnZhciB0aHJvdHRsZVV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC90aHJvdHRsZVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gT25seSBjcmVhdGUgb25lIHJvYW0gY29udHJvbGxlciBmb3IgZWFjaCBjb29yZGluYXRlIHN5c3RlbS5cbi8vIG9uZSByb2FtIGNvbnRyb2xsZXIgbWlnaHQgYmUgcmVmZXJlZCBieSB0d28gaW5zaWRlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cyAoZm9yIGV4YW1wbGUsIG9uZSBmb3IgeCBhbmQgb25lIGZvciB5KS4gV2hlbiB1c2VyXG4vLyBwYW4gb3Igem9vbSwgb25seSBkaXNwYXRjaCBvbmUgYWN0aW9uIGZvciB0aG9zZSBkYXRhIHpvb21cbi8vIGNvbXBvbmVudHMuXG52YXIgQVRUUiA9ICdcXDBfZWNfZGF0YVpvb21fcm9hbXMnO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVpvb21JbmZvXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JbmZvLmNvb3JkSWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby5jb250YWluc1BvaW50XG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBkYXRhWm9vbUluZm8uYWxsQ29vcmRJZHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUluZm8uZGF0YVpvb21JZFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFab29tSW5mby5nZXRSYW5nZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLmdldFJhbmdlLnBhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLmdldFJhbmdlLnpvb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby5nZXRSYW5nZS5zY3JvbGxNb3ZlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRhdGFab29tSW5mby5kYXRhWm9vbU1vZGVsXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXIoYXBpLCBkYXRhWm9vbUluZm8pIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG4gIHZhciB0aGVEYXRhWm9vbUlkID0gZGF0YVpvb21JbmZvLmRhdGFab29tSWQ7XG4gIHZhciB0aGVDb29yZElkID0gZGF0YVpvb21JbmZvLmNvb3JkSWQ7IC8vIERvIGNsZWFuIHdoZW4gYSBkYXRhWm9vbSBjaGFuZ2VzIGl0cyB0YXJnZXQgY29vcmRuYXRlIHN5c3RlbS5cbiAgLy8gQXZvaWQgbWVtb3J5IGxlYWssIGRpc3Bvc2UgYWxsIG5vdC11c2VkLXJlZ2lzdGVyZWQuXG5cbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuXG4gICAgaWYgKGRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgenJVdGlsLmluZGV4T2YoZGF0YVpvb21JbmZvLmFsbENvb3JkSWRzLCB0aGVDb29yZElkKSA8IDApIHtcbiAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdO1xuICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgfVxuICB9KTtcbiAgY2xlYW5TdG9yZShzdG9yZSk7XG4gIHZhciByZWNvcmQgPSBzdG9yZVt0aGVDb29yZElkXTsgLy8gQ3JlYXRlIGlmIG5lZWRlZC5cblxuICBpZiAoIXJlY29yZCkge1xuICAgIHJlY29yZCA9IHN0b3JlW3RoZUNvb3JkSWRdID0ge1xuICAgICAgY29vcmRJZDogdGhlQ29vcmRJZCxcbiAgICAgIGRhdGFab29tSW5mb3M6IHt9LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICAgIHJlY29yZC5jb250cm9sbGVyID0gY3JlYXRlQ29udHJvbGxlcihhcGksIHJlY29yZCk7XG4gICAgcmVjb3JkLmRpc3BhdGNoQWN0aW9uID0genJVdGlsLmN1cnJ5KGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB9IC8vIFVwZGF0ZSByZWZlcmVuY2Ugb2YgZGF0YVpvb20uXG5cblxuICAhcmVjb3JkLmRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgcmVjb3JkLmNvdW50Kys7XG4gIHJlY29yZC5kYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdID0gZGF0YVpvb21JbmZvO1xuICB2YXIgY29udHJvbGxlclBhcmFtcyA9IG1lcmdlQ29udHJvbGxlclBhcmFtcyhyZWNvcmQuZGF0YVpvb21JbmZvcyk7XG4gIHJlY29yZC5jb250cm9sbGVyLmVuYWJsZShjb250cm9sbGVyUGFyYW1zLmNvbnRyb2xUeXBlLCBjb250cm9sbGVyUGFyYW1zLm9wdCk7IC8vIENvbnNpZGVyIHJlc2l6ZSwgYXJlYSBzaG91bGQgYmUgYWx3YXlzIHVwZGF0ZWQuXG5cbiAgcmVjb3JkLmNvbnRyb2xsZXIuc2V0UG9pbnRlckNoZWNrZXIoZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnQpOyAvLyBVcGRhdGUgdGhyb3R0bGUuXG5cbiAgdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHJlY29yZCwgJ2Rpc3BhdGNoQWN0aW9uJywgZGF0YVpvb21JbmZvLmRhdGFab29tTW9kZWwuZ2V0KCd0aHJvdHRsZScsIHRydWUpLCAnZml4UmF0ZScpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JZFxuICovXG5cblxuZnVuY3Rpb24gdW5yZWdpc3RlcihhcGksIGRhdGFab29tSWQpIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG4gIHpyVXRpbC5lYWNoKHN0b3JlLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIHZhciBkYXRhWm9vbUluZm9zID0gcmVjb3JkLmRhdGFab29tSW5mb3M7XG5cbiAgICBpZiAoZGF0YVpvb21JbmZvc1tkYXRhWm9vbUlkXSkge1xuICAgICAgZGVsZXRlIGRhdGFab29tSW5mb3NbZGF0YVpvb21JZF07XG4gICAgICByZWNvcmQuY291bnQtLTtcbiAgICB9XG4gIH0pO1xuICBjbGVhblN0b3JlKHN0b3JlKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVDb29yZElkKGNvb3JkTW9kZWwpIHtcbiAgcmV0dXJuIGNvb3JkTW9kZWwudHlwZSArICdcXDBfJyArIGNvb3JkTW9kZWwuaWQ7XG59XG4vKipcbiAqIEtleTogY29vcmRJZCwgdmFsdWU6IHtkYXRhWm9vbUluZm9zOiBbXSwgY291bnQsIGNvbnRyb2xsZXJ9XG4gKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gKi9cblxuXG5mdW5jdGlvbiBnaXZlU3RvcmUoYXBpKSB7XG4gIC8vIE1vdW50IHN0b3JlIG9uIHpyZW5kZXIgaW5zdGFuY2UsIHNvIHRoYXQgd2UgZG8gbm90XG4gIC8vIG5lZWQgdG8gd29ycnkgYWJvdXQgZGlzcG9zZS5cbiAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gIHJldHVybiB6cltBVFRSXSB8fCAoenJbQVRUUl0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xsZXIoYXBpLCBuZXdSZWNvcmQpIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICB6clV0aWwuZWFjaChbJ3BhbicsICd6b29tJywgJ3Njcm9sbE1vdmUnXSwgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIGNvbnRyb2xsZXIub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBiYXRjaCA9IFtdO1xuICAgICAgenJVdGlsLmVhY2gobmV3UmVjb3JkLmRhdGFab29tSW5mb3MsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGJlaGF2aW9ycyAoem9vbU9uTW91c2VXaGVlbCwgbW92ZU9uTW91c2VNb3ZlLFxuICAgICAgICAvLyBtb3ZlT25Nb3VzZVdoZWVsLCAuLi4pIGVuYWJsZWQuXG4gICAgICAgIGlmICghZXZlbnQuaXNBdmFpbGFibGVCZWhhdmlvcihpbmZvLmRhdGFab29tTW9kZWwub3B0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2QgPSAoaW5mby5nZXRSYW5nZSB8fCB7fSlbZXZlbnROYW1lXTtcbiAgICAgICAgdmFyIHJhbmdlID0gbWV0aG9kICYmIG1ldGhvZChuZXdSZWNvcmQuY29udHJvbGxlciwgZXZlbnQpO1xuICAgICAgICAhaW5mby5kYXRhWm9vbU1vZGVsLmdldCgnZGlzYWJsZWQnLCB0cnVlKSAmJiByYW5nZSAmJiBiYXRjaC5wdXNoKHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBpbmZvLmRhdGFab29tSWQsXG4gICAgICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJhdGNoLmxlbmd0aCAmJiBuZXdSZWNvcmQuZGlzcGF0Y2hBY3Rpb24oYmF0Y2gpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RvcmUoc3RvcmUpIHtcbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICBpZiAoIXJlY29yZC5jb3VudCkge1xuICAgICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIHN0b3JlW2Nvb3JkSWRdO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFRoaXMgYWN0aW9uIHdpbGwgYmUgdGhyb3R0bGVkLlxuICovXG5cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oYXBpLCBiYXRjaCkge1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgYmF0Y2g6IGJhdGNoXG4gIH0pO1xufVxuLyoqXG4gKiBNZXJnZSByb2FtQ29udHJvbGxlciBzZXR0aW5ncyB3aGVuIG11bHRpcGxlIGRhdGFab29tcyBzaGFyZSBvbmUgcm9hbUNvbnRyb2xsZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUNvbnRyb2xsZXJQYXJhbXMoZGF0YVpvb21JbmZvcykge1xuICB2YXIgY29udHJvbFR5cGU7IC8vIERPIE5PVCB1c2UgcmVzZXJ2ZWQgd29yZCAodHJ1ZSwgZmFsc2UsIHVuZGVmaW5lZCkgYXMga2V5IGxpdGVyYWxseS4gRXZlbiBpZiBlbmNhcHN1bGF0ZWRcbiAgLy8gYXMgc3RyaW5nLCBpdCBpcyBwcm9iYWJseSByZXZlcnQgdG8gcmVzZXJ2ZWQgd29yZCBieSBjb21wcmVzcyB0b29sLiBTZWUgIzc0MTEuXG5cbiAgdmFyIHByZWZpeCA9ICd0eXBlXyc7XG4gIHZhciB0eXBlUHJpb3JpdHkgPSB7XG4gICAgJ3R5cGVfdHJ1ZSc6IDIsXG4gICAgJ3R5cGVfbW92ZSc6IDEsXG4gICAgJ3R5cGVfZmFsc2UnOiAwLFxuICAgICd0eXBlX3VuZGVmaW5lZCc6IC0xXG4gIH07XG4gIHZhciBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZSA9IHRydWU7XG4gIHpyVXRpbC5lYWNoKGRhdGFab29tSW5mb3MsIGZ1bmN0aW9uIChkYXRhWm9vbUluZm8pIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tSW5mby5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBvbmVUeXBlID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2Rpc2FibGVkJywgdHJ1ZSkgPyBmYWxzZSA6IGRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycsIHRydWUpID8gJ21vdmUnIDogdHJ1ZTtcblxuICAgIGlmICh0eXBlUHJpb3JpdHlbcHJlZml4ICsgb25lVHlwZV0gPiB0eXBlUHJpb3JpdHlbcHJlZml4ICsgY29udHJvbFR5cGVdKSB7XG4gICAgICBjb250cm9sVHlwZSA9IG9uZVR5cGU7XG4gICAgfSAvLyBQcmV2ZW50IGRlZmF1bHQgbW92ZSBldmVudCBieSBkZWZhdWx0LiBJZiBvbmUgZmFsc2UsIGRvIG5vdCBwcmV2ZW50LiBPdGhlcndpc2VcbiAgICAvLyB1c2VycyBtYXkgYmUgY29uZnVzZWQgd2h5IGl0IGRvZXMgbm90IHdvcmsgd2hlbiBtdWx0aXBsZSBpbnNpZGVab29tcyBleGlzdC5cblxuXG4gICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmUgJj0gZGF0YVpvb21Nb2RlbC5nZXQoJ3ByZXZlbnREZWZhdWx0TW91c2VNb3ZlJywgdHJ1ZSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xUeXBlOiBjb250cm9sVHlwZSxcbiAgICBvcHQ6IHtcbiAgICAgIC8vIFJvYW1Db250cm9sbGVyIHdpbGwgZW5hYmxlIGFsbCBvZiB0aGVzZSBmdW5jdGlvbmFsaXRpZXMsXG4gICAgICAvLyBhbmQgdGhlIGZpbmFsIGJlaGF2aW9yIGlzIGRldGVybWluZWQgYnkgaXRzIGV2ZW50IGxpc3RlbmVyXG4gICAgICAvLyBwcm92aWRlZCBieSBlYWNoIGluc2lkZSB6b29tLlxuICAgICAgem9vbU9uTW91c2VXaGVlbDogdHJ1ZSxcbiAgICAgIG1vdmVPbk1vdXNlTW92ZTogdHJ1ZSxcbiAgICAgIG1vdmVPbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogISFwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcbmV4cG9ydHMuZ2VuZXJhdGVDb29yZElkID0gZ2VuZXJhdGVDb29yZElkOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/roams.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Component = __webpack_require__(/*! ../../model/Component */ \"./node_modules/echarts/lib/model/Component.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3R5cGVEZWZhdWx0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3R5cGVEZWZhdWx0ZXIuanM/NjkzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbkNvbXBvbmVudC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2RhdGFab29tJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gIHJldHVybiAnc2xpZGVyJztcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/RoamController.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/RoamController.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ \"./node_modules/zrender/lib/mixin/Eventful.js\");\n\nvar eventTool = __webpack_require__(/*! zrender/lib/core/event */ \"./node_modules/zrender/lib/core/event.js\");\n\nvar interactionMutex = __webpack_require__(/*! ./interactionMutex */ \"./node_modules/echarts/lib/component/helper/interactionMutex.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n  /**\n   * @type {Function}\n   */\n  this.pointerChecker;\n  /**\n   * @type {module:zrender}\n   */\n\n  this._zr = zr;\n  /**\n   * @type {Object}\n   */\n\n  this._opt = {}; // Avoid two roamController bind the same handler\n\n  var bind = zrUtil.bind;\n  var mousedownHandler = bind(mousedown, this);\n  var mousemoveHandler = bind(mousemove, this);\n  var mouseupHandler = bind(mouseup, this);\n  var mousewheelHandler = bind(mousewheel, this);\n  var pinchHandler = bind(pinch, this);\n  Eventful.call(this);\n  /**\n   * @param {Function} pointerChecker\n   *                   input: x, y\n   *                   output: boolean\n   */\n\n  this.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  /**\n   * Notice: only enable needed types. For example, if 'zoom'\n   * is not needed, 'zoom' should not be enabled, otherwise\n   * default mousewheel behaviour (scroll page) will be disabled.\n   *\n   * @param  {boolean|string} [controlType=true] Specify the control type,\n   *                          which can be null/undefined or true/false\n   *                          or 'pan/move' or 'zoom'/'scale'\n   * @param {Object} [opt]\n   * @param {Object} [opt.zoomOnMouseWheel=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\n   * @param {Object} [opt.moveOnMouseMove=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\n   * @param {Object} [opt.moveOnMouseWheel=false] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\n   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n   */\n\n\n  this.enable = function (controlType, opt) {\n    // Disable previous first\n    this.disable();\n    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      // By default, wheel do not trigger move.\n      moveOnMouseWheel: false,\n      preventDefaultMouseMove: true\n    });\n\n    if (controlType == null) {\n      controlType = true;\n    }\n\n    if (controlType === true || controlType === 'move' || controlType === 'pan') {\n      zr.on('mousedown', mousedownHandler);\n      zr.on('mousemove', mousemoveHandler);\n      zr.on('mouseup', mouseupHandler);\n    }\n\n    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n      zr.on('mousewheel', mousewheelHandler);\n      zr.on('pinch', pinchHandler);\n    }\n  };\n\n  this.disable = function () {\n    zr.off('mousedown', mousedownHandler);\n    zr.off('mousemove', mousemoveHandler);\n    zr.off('mouseup', mouseupHandler);\n    zr.off('mousewheel', mousewheelHandler);\n    zr.off('pinch', pinchHandler);\n  };\n\n  this.dispose = this.disable;\n\n  this.isDragging = function () {\n    return this._dragging;\n  };\n\n  this.isPinching = function () {\n    return this._pinching;\n  };\n}\n\nzrUtil.mixin(RoamController, Eventful);\n\nfunction mousedown(e) {\n  if (eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY; // Only check on mosedown, but not mousemove.\n  // Mouse can be out of target when mouse moving.\n\n  if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n    this._x = x;\n    this._y = y;\n    this._dragging = true;\n  }\n}\n\nfunction mousemove(e) {\n  if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY;\n  var oldX = this._x;\n  var oldY = this._y;\n  var dx = x - oldX;\n  var dy = y - oldY;\n  this._x = x;\n  this._y = y;\n  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);\n  trigger(this, 'pan', 'moveOnMouseMove', e, {\n    dx: dx,\n    dy: dy,\n    oldX: oldX,\n    oldY: oldY,\n    newX: x,\n    newY: y\n  });\n}\n\nfunction mouseup(e) {\n  if (!eventTool.isMiddleOrRightButtonOnMouseUpDown(e)) {\n    this._dragging = false;\n  }\n}\n\nfunction mousewheel(e) {\n  var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);\n  var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);\n  var wheelDelta = e.wheelDelta;\n  var absWheelDeltaDelta = Math.abs(wheelDelta);\n  var originX = e.offsetX;\n  var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.\n\n  if (wheelDelta === 0 || !shouldZoom && !shouldMove) {\n    return;\n  } // If both `shouldZoom` and `shouldMove` is true, trigger\n  // their event both, and the final behavior is determined\n  // by event listener themselves.\n\n\n  if (shouldZoom) {\n    // Convenience:\n    // Mac and VM Windows on Mac: scroll up: zoom out.\n    // Windows: scroll up: zoom in.\n    // FIXME: Should do more test in different environment.\n    // wheelDelta is too complicated in difference nvironment\n    // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),\n    // although it has been normallized by zrender.\n    // wheelDelta of mouse wheel is bigger than touch pad.\n    var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;\n    var scale = wheelDelta > 0 ? factor : 1 / factor;\n    checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {\n      scale: scale,\n      originX: originX,\n      originY: originY\n    });\n  }\n\n  if (shouldMove) {\n    // FIXME: Should do more test in different environment.\n    var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.\n\n    var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);\n    checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {\n      scrollDelta: scrollDelta,\n      originX: originX,\n      originY: originY\n    });\n  }\n}\n\nfunction pinch(e) {\n  if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n  checkPointerAndTrigger(this, 'zoom', null, e, {\n    scale: scale,\n    originX: e.pinchX,\n    originY: e.pinchY\n  });\n}\n\nfunction checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    eventTool.stop(e.event);\n    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);\n  }\n}\n\nfunction trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  // Also provide behavior checker for event listener, for some case that\n  // multiple components share one listener.\n  contollerEvent.isAvailableBehavior = zrUtil.bind(isAvailableBehavior, null, behaviorToCheck, e);\n  controller.trigger(eventName, contollerEvent);\n} // settings: {\n//     zoomOnMouseWheel\n//     moveOnMouseMove\n//     moveOnMouseWheel\n// }\n// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\n\n\nfunction isAvailableBehavior(behaviorToCheck, e, settings) {\n  var setting = settings[behaviorToCheck];\n  return !behaviorToCheck || setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);\n}\n\nvar _default = RoamController;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyLmpzPzRhMDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBldmVudFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGludGVyYWN0aW9uTXV0ZXggPSByZXF1aXJlKFwiLi9pbnRlcmFjdGlvbk11dGV4XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGluIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn0genJcbiAqL1xuZnVuY3Rpb24gUm9hbUNvbnRyb2xsZXIoenIpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMucG9pbnRlckNoZWNrZXI7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXJ9XG4gICAqL1xuXG4gIHRoaXMuX3pyID0genI7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9vcHQgPSB7fTsgLy8gQXZvaWQgdHdvIHJvYW1Db250cm9sbGVyIGJpbmQgdGhlIHNhbWUgaGFuZGxlclxuXG4gIHZhciBiaW5kID0genJVdGlsLmJpbmQ7XG4gIHZhciBtb3VzZWRvd25IYW5kbGVyID0gYmluZChtb3VzZWRvd24sIHRoaXMpO1xuICB2YXIgbW91c2Vtb3ZlSGFuZGxlciA9IGJpbmQobW91c2Vtb3ZlLCB0aGlzKTtcbiAgdmFyIG1vdXNldXBIYW5kbGVyID0gYmluZChtb3VzZXVwLCB0aGlzKTtcbiAgdmFyIG1vdXNld2hlZWxIYW5kbGVyID0gYmluZChtb3VzZXdoZWVsLCB0aGlzKTtcbiAgdmFyIHBpbmNoSGFuZGxlciA9IGJpbmQocGluY2gsIHRoaXMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9pbnRlckNoZWNrZXJcbiAgICogICAgICAgICAgICAgICAgICAgaW5wdXQ6IHgsIHlcbiAgICogICAgICAgICAgICAgICAgICAgb3V0cHV0OiBib29sZWFuXG4gICAqL1xuXG4gIHRoaXMuc2V0UG9pbnRlckNoZWNrZXIgPSBmdW5jdGlvbiAocG9pbnRlckNoZWNrZXIpIHtcbiAgICB0aGlzLnBvaW50ZXJDaGVja2VyID0gcG9pbnRlckNoZWNrZXI7XG4gIH07XG4gIC8qKlxuICAgKiBOb3RpY2U6IG9ubHkgZW5hYmxlIG5lZWRlZCB0eXBlcy4gRm9yIGV4YW1wbGUsIGlmICd6b29tJ1xuICAgKiBpcyBub3QgbmVlZGVkLCAnem9vbScgc2hvdWxkIG5vdCBiZSBlbmFibGVkLCBvdGhlcndpc2VcbiAgICogZGVmYXVsdCBtb3VzZXdoZWVsIGJlaGF2aW91ciAoc2Nyb2xsIHBhZ2UpIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58c3RyaW5nfSBbY29udHJvbFR5cGU9dHJ1ZV0gU3BlY2lmeSB0aGUgY29udHJvbCB0eXBlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggY2FuIGJlIG51bGwvdW5kZWZpbmVkIG9yIHRydWUvZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yICdwYW4vbW92ZScgb3IgJ3pvb20nLydzY2FsZSdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lnpvb21Pbk1vdXNlV2hlZWw9dHJ1ZV0gVGhlIHZhbHVlIGNhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5tb3ZlT25Nb3VzZU1vdmU9dHJ1ZV0gVGhlIHZhbHVlIGNhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5tb3ZlT25Nb3VzZVdoZWVsPWZhbHNlXSBUaGUgdmFsdWUgY2FuIGJlOiB0cnVlIC8gZmFsc2UgLyAnc2hpZnQnIC8gJ2N0cmwnIC8gJ2FsdCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnByZXZlbnREZWZhdWx0TW91c2VNb3ZlPXRydWVdIFdoZW4gcGFuLlxuICAgKi9cblxuXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGNvbnRyb2xUeXBlLCBvcHQpIHtcbiAgICAvLyBEaXNhYmxlIHByZXZpb3VzIGZpcnN0XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fb3B0ID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5jbG9uZShvcHQpIHx8IHt9LCB7XG4gICAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgbW92ZU9uTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlZWwgZG8gbm90IHRyaWdnZXIgbW92ZS5cbiAgICAgIG1vdmVPbk1vdXNlV2hlZWw6IGZhbHNlLFxuICAgICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjb250cm9sVHlwZSA9PSBudWxsKSB7XG4gICAgICBjb250cm9sVHlwZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IGNvbnRyb2xUeXBlID09PSAnbW92ZScgfHwgY29udHJvbFR5cGUgPT09ICdwYW4nKSB7XG4gICAgICB6ci5vbignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgICB6ci5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICB6ci5vbignbW91c2V1cCcsIG1vdXNldXBIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdzY2FsZScgfHwgY29udHJvbFR5cGUgPT09ICd6b29tJykge1xuICAgICAgenIub24oJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICB6ci5vbigncGluY2gnLCBwaW5jaEhhbmRsZXIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgenIub2ZmKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICB6ci5vZmYoJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgIHpyLm9mZignbW91c2V1cCcsIG1vdXNldXBIYW5kbGVyKTtcbiAgICB6ci5vZmYoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgenIub2ZmKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gIH07XG5cbiAgdGhpcy5kaXNwb3NlID0gdGhpcy5kaXNhYmxlO1xuXG4gIHRoaXMuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmc7XG4gIH07XG5cbiAgdGhpcy5pc1BpbmNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9waW5jaGluZztcbiAgfTtcbn1cblxuenJVdGlsLm1peGluKFJvYW1Db250cm9sbGVyLCBFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gIGlmIChldmVudFRvb2wuaXNNaWRkbGVPclJpZ2h0QnV0dG9uT25Nb3VzZVVwRG93bihlKSB8fCBlLnRhcmdldCAmJiBlLnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgdmFyIHkgPSBlLm9mZnNldFk7IC8vIE9ubHkgY2hlY2sgb24gbW9zZWRvd24sIGJ1dCBub3QgbW91c2Vtb3ZlLlxuICAvLyBNb3VzZSBjYW4gYmUgb3V0IG9mIHRhcmdldCB3aGVuIG1vdXNlIG1vdmluZy5cblxuICBpZiAodGhpcy5wb2ludGVyQ2hlY2tlciAmJiB0aGlzLnBvaW50ZXJDaGVja2VyKGUsIHgsIHkpKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlbW92ZShlKSB7XG4gIGlmICghdGhpcy5fZHJhZ2dpbmcgfHwgIWlzQXZhaWxhYmxlQmVoYXZpb3IoJ21vdmVPbk1vdXNlTW92ZScsIGUsIHRoaXMuX29wdCkgfHwgZS5nZXN0dXJlRXZlbnQgPT09ICdwaW5jaCcgfHwgaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgdmFyIHkgPSBlLm9mZnNldFk7XG4gIHZhciBvbGRYID0gdGhpcy5feDtcbiAgdmFyIG9sZFkgPSB0aGlzLl95O1xuICB2YXIgZHggPSB4IC0gb2xkWDtcbiAgdmFyIGR5ID0geSAtIG9sZFk7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5fb3B0LnByZXZlbnREZWZhdWx0TW91c2VNb3ZlICYmIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICB0cmlnZ2VyKHRoaXMsICdwYW4nLCAnbW92ZU9uTW91c2VNb3ZlJywgZSwge1xuICAgIGR4OiBkeCxcbiAgICBkeTogZHksXG4gICAgb2xkWDogb2xkWCxcbiAgICBvbGRZOiBvbGRZLFxuICAgIG5ld1g6IHgsXG4gICAgbmV3WTogeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gIGlmICghZXZlbnRUb29sLmlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24oZSkpIHtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNld2hlZWwoZSkge1xuICB2YXIgc2hvdWxkWm9vbSA9IGlzQXZhaWxhYmxlQmVoYXZpb3IoJ3pvb21Pbk1vdXNlV2hlZWwnLCBlLCB0aGlzLl9vcHQpO1xuICB2YXIgc2hvdWxkTW92ZSA9IGlzQXZhaWxhYmxlQmVoYXZpb3IoJ21vdmVPbk1vdXNlV2hlZWwnLCBlLCB0aGlzLl9vcHQpO1xuICB2YXIgd2hlZWxEZWx0YSA9IGUud2hlZWxEZWx0YTtcbiAgdmFyIGFic1doZWVsRGVsdGFEZWx0YSA9IE1hdGguYWJzKHdoZWVsRGVsdGEpO1xuICB2YXIgb3JpZ2luWCA9IGUub2Zmc2V0WDtcbiAgdmFyIG9yaWdpblkgPSBlLm9mZnNldFk7IC8vIHdoZWVsRGVsdGEgbWF5YmUgLTAgaW4gY2hyb21lIG1hYy5cblxuICBpZiAod2hlZWxEZWx0YSA9PT0gMCB8fCAhc2hvdWxkWm9vbSAmJiAhc2hvdWxkTW92ZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiBib3RoIGBzaG91bGRab29tYCBhbmQgYHNob3VsZE1vdmVgIGlzIHRydWUsIHRyaWdnZXJcbiAgLy8gdGhlaXIgZXZlbnQgYm90aCwgYW5kIHRoZSBmaW5hbCBiZWhhdmlvciBpcyBkZXRlcm1pbmVkXG4gIC8vIGJ5IGV2ZW50IGxpc3RlbmVyIHRoZW1zZWx2ZXMuXG5cblxuICBpZiAoc2hvdWxkWm9vbSkge1xuICAgIC8vIENvbnZlbmllbmNlOlxuICAgIC8vIE1hYyBhbmQgVk0gV2luZG93cyBvbiBNYWM6IHNjcm9sbCB1cDogem9vbSBvdXQuXG4gICAgLy8gV2luZG93czogc2Nyb2xsIHVwOiB6b29tIGluLlxuICAgIC8vIEZJWE1FOiBTaG91bGQgZG8gbW9yZSB0ZXN0IGluIGRpZmZlcmVudCBlbnZpcm9ubWVudC5cbiAgICAvLyB3aGVlbERlbHRhIGlzIHRvbyBjb21wbGljYXRlZCBpbiBkaWZmZXJlbmNlIG52aXJvbm1lbnRcbiAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL21vdXNld2hlZWwpLFxuICAgIC8vIGFsdGhvdWdoIGl0IGhhcyBiZWVuIG5vcm1hbGxpemVkIGJ5IHpyZW5kZXIuXG4gICAgLy8gd2hlZWxEZWx0YSBvZiBtb3VzZSB3aGVlbCBpcyBiaWdnZXIgdGhhbiB0b3VjaCBwYWQuXG4gICAgdmFyIGZhY3RvciA9IGFic1doZWVsRGVsdGFEZWx0YSA+IDMgPyAxLjQgOiBhYnNXaGVlbERlbHRhRGVsdGEgPiAxID8gMS4yIDogMS4xO1xuICAgIHZhciBzY2FsZSA9IHdoZWVsRGVsdGEgPiAwID8gZmFjdG9yIDogMSAvIGZhY3RvcjtcbiAgICBjaGVja1BvaW50ZXJBbmRUcmlnZ2VyKHRoaXMsICd6b29tJywgJ3pvb21Pbk1vdXNlV2hlZWwnLCBlLCB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBvcmlnaW5YOiBvcmlnaW5YLFxuICAgICAgb3JpZ2luWTogb3JpZ2luWVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNob3VsZE1vdmUpIHtcbiAgICAvLyBGSVhNRTogU2hvdWxkIGRvIG1vcmUgdGVzdCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnQuXG4gICAgdmFyIGFic0RlbHRhID0gTWF0aC5hYnMod2hlZWxEZWx0YSk7IC8vIHdoZWVsRGVsdGEgb2YgbW91c2Ugd2hlZWwgaXMgYmlnZ2VyIHRoYW4gdG91Y2ggcGFkLlxuXG4gICAgdmFyIHNjcm9sbERlbHRhID0gKHdoZWVsRGVsdGEgPiAwID8gMSA6IC0xKSAqIChhYnNEZWx0YSA+IDMgPyAwLjQgOiBhYnNEZWx0YSA+IDEgPyAwLjE1IDogMC4wNSk7XG4gICAgY2hlY2tQb2ludGVyQW5kVHJpZ2dlcih0aGlzLCAnc2Nyb2xsTW92ZScsICdtb3ZlT25Nb3VzZVdoZWVsJywgZSwge1xuICAgICAgc2Nyb2xsRGVsdGE6IHNjcm9sbERlbHRhLFxuICAgICAgb3JpZ2luWDogb3JpZ2luWCxcbiAgICAgIG9yaWdpblk6IG9yaWdpbllcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwaW5jaChlKSB7XG4gIGlmIChpbnRlcmFjdGlvbk11dGV4LmlzVGFrZW4odGhpcy5fenIsICdnbG9iYWxQYW4nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IGUucGluY2hTY2FsZSA+IDEgPyAxLjEgOiAxIC8gMS4xO1xuICBjaGVja1BvaW50ZXJBbmRUcmlnZ2VyKHRoaXMsICd6b29tJywgbnVsbCwgZSwge1xuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBvcmlnaW5YOiBlLnBpbmNoWCxcbiAgICBvcmlnaW5ZOiBlLnBpbmNoWVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tQb2ludGVyQW5kVHJpZ2dlcihjb250cm9sbGVyLCBldmVudE5hbWUsIGJlaGF2aW9yVG9DaGVjaywgZSwgY29udG9sbGVyRXZlbnQpIHtcbiAgaWYgKGNvbnRyb2xsZXIucG9pbnRlckNoZWNrZXIgJiYgY29udHJvbGxlci5wb2ludGVyQ2hlY2tlcihlLCBjb250b2xsZXJFdmVudC5vcmlnaW5YLCBjb250b2xsZXJFdmVudC5vcmlnaW5ZKSkge1xuICAgIC8vIFdoZW4gbW91c2UgaXMgb3V0IG9mIHJvYW1Db250cm9sbGVyIHJlY3QsXG4gICAgLy8gZGVmYXVsdCBiZWZhdm9pdXMgc2hvdWxkIG5vdCBiZSBiZSBkaXNhYmxlZCwgb3RoZXJ3aXNlXG4gICAgLy8gcGFnZSBzbGlkaW5nIGlzIGRpc2FibGVkLCBjb250cmFyeSB0byBleHBlY3RhdGlvbi5cbiAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICB0cmlnZ2VyKGNvbnRyb2xsZXIsIGV2ZW50TmFtZSwgYmVoYXZpb3JUb0NoZWNrLCBlLCBjb250b2xsZXJFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihjb250cm9sbGVyLCBldmVudE5hbWUsIGJlaGF2aW9yVG9DaGVjaywgZSwgY29udG9sbGVyRXZlbnQpIHtcbiAgLy8gQWxzbyBwcm92aWRlIGJlaGF2aW9yIGNoZWNrZXIgZm9yIGV2ZW50IGxpc3RlbmVyLCBmb3Igc29tZSBjYXNlIHRoYXRcbiAgLy8gbXVsdGlwbGUgY29tcG9uZW50cyBzaGFyZSBvbmUgbGlzdGVuZXIuXG4gIGNvbnRvbGxlckV2ZW50LmlzQXZhaWxhYmxlQmVoYXZpb3IgPSB6clV0aWwuYmluZChpc0F2YWlsYWJsZUJlaGF2aW9yLCBudWxsLCBiZWhhdmlvclRvQ2hlY2ssIGUpO1xuICBjb250cm9sbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBjb250b2xsZXJFdmVudCk7XG59IC8vIHNldHRpbmdzOiB7XG4vLyAgICAgem9vbU9uTW91c2VXaGVlbFxuLy8gICAgIG1vdmVPbk1vdXNlTW92ZVxuLy8gICAgIG1vdmVPbk1vdXNlV2hlZWxcbi8vIH1cbi8vIFRoZSB2YWx1ZSBjYW4gYmU6IHRydWUgLyBmYWxzZSAvICdzaGlmdCcgLyAnY3RybCcgLyAnYWx0Jy5cblxuXG5mdW5jdGlvbiBpc0F2YWlsYWJsZUJlaGF2aW9yKGJlaGF2aW9yVG9DaGVjaywgZSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmcgPSBzZXR0aW5nc1tiZWhhdmlvclRvQ2hlY2tdO1xuICByZXR1cm4gIWJlaGF2aW9yVG9DaGVjayB8fCBzZXR0aW5nICYmICghenJVdGlsLmlzU3RyaW5nKHNldHRpbmcpIHx8IGUuZXZlbnRbc2V0dGluZyArICdLZXknXSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IFJvYW1Db250cm9sbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/helper/RoamController.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/interactionMutex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/interactionMutex.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = __webpack_require__(/*! ../../echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcz9hNGZlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgQVRUUiA9ICdcXDBfZWNfaW50ZXJhY3Rpb25fbXV0ZXgnO1xuXG5mdW5jdGlvbiB0YWtlKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gIHN0b3JlW3Jlc291cmNlS2V5XSA9IHVzZXJLZXk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2UoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgdmFyIHVLZXkgPSBzdG9yZVtyZXNvdXJjZUtleV07XG5cbiAgaWYgKHVLZXkgPT09IHVzZXJLZXkpIHtcbiAgICBzdG9yZVtyZXNvdXJjZUtleV0gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGFrZW4oenIsIHJlc291cmNlS2V5KSB7XG4gIHJldHVybiAhIWdldFN0b3JlKHpyKVtyZXNvdXJjZUtleV07XG59XG5cbmZ1bmN0aW9uIGdldFN0b3JlKHpyKSB7XG4gIHJldHVybiB6cltBVFRSXSB8fCAoenJbQVRUUl0gPSB7fSk7XG59XG4vKipcbiAqIHBheWxvYWQ6IHtcbiAqICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gKiAgICAga2V5OiAnZGF0YVpvb21TZWxlY3QnLCBvciAnYnJ1c2gnLCBvciAuLi4sXG4gKiAgICAgICAgIElmIG5vIHVzZXJLZXksIHJlbGVhc2UgZ2xvYmFsIGN1cnNvci5cbiAqIH1cbiAqL1xuXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gIGV2ZW50OiAnZ2xvYmFsQ3Vyc29yVGFrZW4nLFxuICB1cGRhdGU6ICd1cGRhdGUnXG59LCBmdW5jdGlvbiAoKSB7fSk7XG5leHBvcnRzLnRha2UgPSB0YWtlO1xuZXhwb3J0cy5yZWxlYXNlID0gcmVsZWFzZTtcbmV4cG9ydHMuaXNUYWtlbiA9IGlzVGFrZW47Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/helper/interactionMutex.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/sliderMove.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/sliderMove.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9zbGlkZXJNb3ZlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qcz9lZjZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQ2FsY3VsYXRlIHNsaWRlciBtb3ZlIHJlc3VsdC5cbiAqIFVzYWdlOlxuICogKDEpIElmIGJvdGggaGFuZGxlMCBhbmQgaGFuZGxlMSBhcmUgbmVlZGVkIHRvIGJlIG1vdmVkLCBzZXQgbWluU3BhbiB0aGUgc2FtZSBhc1xuICogbWF4U3BhbiBhbmQgdGhlIHNhbWUgYXMgYE1hdGguYWJzKGhhbmRsZUVuZFsxXSAtIGhhbmRsZUVuZHNbMF0pYC5cbiAqICgyKSBJZiBoYW5kbGUwIGlzIGZvcmJpZGRlbiB0byBjcm9zcyBoYW5kbGUxLCBzZXQgbWluU3BhbiBhcyBgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIE1vdmUgbGVuZ3RoLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaGFuZGxlRW5kcyBoYW5kbGVFbmRzWzBdIGNhbiBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLlxuICogICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBoYW5kbGVFbmRzIGlzIHJlc3RyaWN0ZWQgYnkgZXh0ZW50LlxuICogICAgICAgICAgICAgIGV4dGVudFswXSBzaG91bGQgbGVzcyBvciBlcXVhbHMgdGhhbiBleHRlbnRbMV0uXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGhhbmRsZUluZGV4IENhbiBiZSAnYWxsJywgbWVhbnMgdGhhdCBib3RoIG1vdmUgdGhlIHR3byBoYW5kbGVFbmRzLFxuICogICAgICAgICAgICAgIHdoZXJlIHRoZSBpbnB1dCBtaW5TcGFuIGFuZCBtYXhTcGFuIHdpbGwgbm90IHdvcmsuXG4gKiBAcGFyYW0ge251bWJlcn0gW21pblNwYW5dIFRoZSByYW5nZSBvZiBkYXRhWm9vbSBjYW4gbm90IGJlIHNtYWxsZXIgdGhhbiB0aGF0LlxuICogICAgICAgICAgICAgIElmIG5vdCBzZXQsIGhhbmRsZTAgYW5kIGNyb3NzIGhhbmRsZTEuIElmIHNldCBhcyBhIG5vbi1uZWdhdGl2ZVxuICogICAgICAgICAgICAgIG51bWJlciAoaW5jbHVkaW5nIGAwYCksIGhhbmRsZXMgd2lsbCBwdXNoIGVhY2ggb3RoZXIgd2hlbiByZWFjaGluZ1xuICogICAgICAgICAgICAgIHRoZSBtaW5TcGFuLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhTcGFuXSBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBsYXJnZXIgdGhhbiB0aGF0LlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSBpbnB1dCBoYW5kbGVFbmRzLlxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChkZWx0YSwgaGFuZGxlRW5kcywgZXh0ZW50LCBoYW5kbGVJbmRleCwgbWluU3BhbiwgbWF4U3Bhbikge1xuICAvLyBOb3JtYWxpemUgZmlyc3RseS5cbiAgaGFuZGxlRW5kc1swXSA9IHJlc3RyaWN0KGhhbmRsZUVuZHNbMF0sIGV4dGVudCk7XG4gIGhhbmRsZUVuZHNbMV0gPSByZXN0cmljdChoYW5kbGVFbmRzWzFdLCBleHRlbnQpO1xuICBkZWx0YSA9IGRlbHRhIHx8IDA7XG4gIHZhciBleHRlbnRTcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBOb3RpY2UgbWF4U3BhbiBhbmQgbWluU3BhbiBjYW4gYmUgbnVsbC91bmRlZmluZWQuXG5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCkge1xuICAgIG1pblNwYW4gPSByZXN0cmljdChtaW5TcGFuLCBbMCwgZXh0ZW50U3Bhbl0pO1xuICB9XG5cbiAgaWYgKG1heFNwYW4gIT0gbnVsbCkge1xuICAgIG1heFNwYW4gPSBNYXRoLm1heChtYXhTcGFuLCBtaW5TcGFuICE9IG51bGwgPyBtaW5TcGFuIDogMCk7XG4gIH1cblxuICBpZiAoaGFuZGxlSW5kZXggPT09ICdhbGwnKSB7XG4gICAgbWluU3BhbiA9IG1heFNwYW4gPSBNYXRoLmFicyhoYW5kbGVFbmRzWzFdIC0gaGFuZGxlRW5kc1swXSk7XG4gICAgaGFuZGxlSW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhOyAvLyBSZXN0cmljdCBpbiBleHRlbnQuXG5cbiAgdmFyIGV4dGVudE1pblNwYW4gPSBtaW5TcGFuIHx8IDA7XG4gIHZhciByZWFsRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiA8IDAgPyByZWFsRXh0ZW50WzBdICs9IGV4dGVudE1pblNwYW4gOiByZWFsRXh0ZW50WzFdIC09IGV4dGVudE1pblNwYW47XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHJlYWxFeHRlbnQpOyAvLyBFeHBhbmQgc3Bhbi5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtaW5TcGFuICE9IG51bGwgJiYgKGN1cnJEaXN0U2lnbi5zaWduICE9PSBvcmlnaW5hbERpc3RTaWduLnNpZ24gfHwgY3VyckRpc3RTaWduLnNwYW4gPCBtaW5TcGFuKSkge1xuICAgIC8vIElmIG1pblNwYW4gZXhpc3RzLCAnY3Jvc3MnIGlzIGZvcmJpbmRlbi5cbiAgICBoYW5kbGVFbmRzWzEgLSBoYW5kbGVJbmRleF0gPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiAqIG1pblNwYW47XG4gIH0gLy8gU2hyaW5rIHNwYW4uXG5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtYXhTcGFuICE9IG51bGwgJiYgY3VyckRpc3RTaWduLnNwYW4gPiBtYXhTcGFuKSB7XG4gICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyBjdXJyRGlzdFNpZ24uc2lnbiAqIG1heFNwYW47XG4gIH1cblxuICByZXR1cm4gaGFuZGxlRW5kcztcbn1cblxuZnVuY3Rpb24gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpIHtcbiAgdmFyIGRpc3QgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSAtIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XTsgLy8gSWYgYGhhbmRsZUVuZHNbMF0gPT09IGhhbmRsZUVuZHNbMV1gLCBhbHdheXMgYmVsaWV2ZSB0aGF0IGhhbmRsZUVuZFswXVxuICAvLyBpcyBhdCBsZWZ0IG9mIGhhbmRsZUVuZHNbMV0gZm9yIG5vbi1jcm9zcyBjYXNlLlxuXG4gIHJldHVybiB7XG4gICAgc3BhbjogTWF0aC5hYnMoZGlzdCksXG4gICAgc2lnbjogZGlzdCA+IDAgPyAtMSA6IGRpc3QgPCAwID8gMSA6IGhhbmRsZUluZGV4ID8gLTEgOiAxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc3RyaWN0KHZhbHVlLCBleHRlbmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKGV4dGVuZFsxXSwgTWF0aC5tYXgoZXh0ZW5kWzBdLCB2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/helper/sliderMove.js\n");

/***/ })

}]);