(this["webpackJsonp"] = this["webpackJsonp"] || []).push([[55],{

/***/ "./node_modules/echarts/lib/chart/helper/Symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/Symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar _symbol = __webpack_require__(/*! ../../util/symbol */ \"./node_modules/echarts/lib/util/symbol.js\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(/*! ../../util/graphic */ \"./node_modules/echarts/lib/util/graphic.js\");\n\nvar _number = __webpack_require__(/*! ../../util/number */ \"./node_modules/echarts/lib/util/number.js\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(/*! ./labelHelper */ \"./node_modules/echarts/lib/chart/helper/labelHelper.js\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n/**\n * @public\n * @static\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {Array.<number>} [width, height]\n */\n\nvar getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n};\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var liftZ = data.getItemVisual(idx, 'liftZ');\n  var z2Origin = symbolPath.__z2Origin;\n\n  if (liftZ != null) {\n    if (z2Origin == null) {\n      symbolPath.__z2Origin = symbolPath.z2;\n      symbolPath.z2 += liftZ;\n    }\n  } else if (z2Origin != null) {\n    symbolPath.z2 = z2Origin;\n    symbolPath.__z2Origin = null;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  symbolPath.__symbolOriginalScale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    // Note: consider `off`, should use static function here.\n    symbolPath.on('mouseover', onMouseOver).on('mouseout', onMouseOut).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n\nfunction onMouseOver() {\n  // see comment in `graphic.isInEmphasis`\n  !graphic.isInEmphasis(this) && onEmphasis.call(this);\n}\n\nfunction onMouseOut() {\n  // see comment in `graphic.isInEmphasis`\n  !graphic.isInEmphasis(this) && onNormal.call(this);\n}\n\nfunction onEmphasis() {\n  // Do not support this hover animation util some scenario required.\n  // Animation can only be supported in hover layer when using `el.incremetal`.\n  if (this.incremental || this.useHoverLayer) {\n    return;\n  }\n\n  var scale = this.__symbolOriginalScale;\n  var ratio = scale[1] / scale[0];\n  this.animateTo({\n    scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n  }, 400, 'elasticOut');\n}\n\nfunction onNormal() {\n  if (this.incremental || this.useHoverLayer) {\n    return;\n  }\n\n  this.animateTo({\n    scale: this.__symbolOriginalScale\n  }, 400, 'elasticOut');\n}\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzPzE0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3N5bWJvbFwiKTtcblxudmFyIGNyZWF0ZVN5bWJvbCA9IF9zeW1ib2wuY3JlYXRlU3ltYm9sO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgcGFyc2VQZXJjZW50ID0gX251bWJlci5wYXJzZVBlcmNlbnQ7XG5cbnZhciBfbGFiZWxIZWxwZXIgPSByZXF1aXJlKFwiLi9sYWJlbEhlbHBlclwiKTtcblxudmFyIGdldERlZmF1bHRMYWJlbCA9IF9sYWJlbEhlbHBlci5nZXREZWZhdWx0TGFiZWw7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbFxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2x9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gKi9cbmZ1bmN0aW9uIFN5bWJvbENseihkYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcbiAgdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xufVxuXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2xDbHoucHJvdG90eXBlO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt3aWR0aCwgaGVpZ2h0XVxuICovXG5cbnZhciBnZXRTeW1ib2xTaXplID0gU3ltYm9sQ2x6LmdldFN5bWJvbFNpemUgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG4gIHZhciBzeW1ib2xTaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKTtcbiAgcmV0dXJuIHN5bWJvbFNpemUgaW5zdGFuY2VvZiBBcnJheSA/IHN5bWJvbFNpemUuc2xpY2UoKSA6IFsrc3ltYm9sU2l6ZSwgK3N5bWJvbFNpemVdO1xufTtcblxuZnVuY3Rpb24gZ2V0U2NhbGUoc3ltYm9sU2l6ZSkge1xuICByZXR1cm4gW3N5bWJvbFNpemVbMF0gLyAyLCBzeW1ib2xTaXplWzFdIC8gMl07XG59XG5cbmZ1bmN0aW9uIGRyaWZ0U3ltYm9sKGR4LCBkeSkge1xuICB0aGlzLnBhcmVudC5kcmlmdChkeCwgZHkpO1xufVxuXG5zeW1ib2xQcm90by5fY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbFR5cGUsIGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwga2VlcEFzcGVjdCkge1xuICAvLyBSZW1vdmUgcGF0aHMgY3JlYXRlZCBiZWZvcmVcbiAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7IC8vIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKFxuICAvLyAgICAgc3ltYm9sVHlwZSwgLTAuNSwgLTAuNSwgMSwgMSwgY29sb3JcbiAgLy8gKTtcbiAgLy8gSWYgd2lkdGgvaGVpZ2h0IGFyZSBzZXQgdG9vIHNtYWxsIChlLmcuLCBzZXQgdG8gMSkgb24gaW9zMTBcbiAgLy8gYW5kIG1hY09TIFNpZXJyYSwgYSBjaXJjbGUgc3Ryb2tlIGJlY29tZSBhIHJlY3QsIG5vIG1hdHRlciB3aGF0XG4gIC8vIHRoZSBzY2FsZSBpcyBzZXQuIFNvIHdlIHNldCB3aWR0aC9oZWlnaHQgYXMgMi4gU2VlICM0MTUwLlxuXG4gIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC0xLCAtMSwgMiwgMiwgY29sb3IsIGtlZXBBc3BlY3QpO1xuICBzeW1ib2xQYXRoLmF0dHIoe1xuICAgIHoyOiAxMDAsXG4gICAgY3VsbGluZzogdHJ1ZSxcbiAgICBzY2FsZTogZ2V0U2NhbGUoc3ltYm9sU2l6ZSlcbiAgfSk7IC8vIFJld3JpdGUgZHJpZnQgbWV0aG9kXG5cbiAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuICB0aGlzLl9zeW1ib2xUeXBlID0gc3ltYm9sVHlwZTtcbiAgdGhpcy5hZGQoc3ltYm9sUGF0aCk7XG59O1xuLyoqXG4gKiBTdG9wIGFuaW1hdGlvblxuICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICovXG5cblxuc3ltYm9sUHJvdG8uc3RvcFN5bWJvbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0b0xhc3RGcmFtZSkge1xuICB0aGlzLmNoaWxkQXQoMCkuc3RvcEFuaW1hdGlvbih0b0xhc3RGcmFtZSk7XG59O1xuLyoqXG4gKiBGSVhNRTpcbiAqIENhdXRpb246IFRoaXMgbWV0aG9kIGJyZWFrcyB0aGUgZW5jYXBzdWxhdGlvbiBvZiB0aGlzIG1vZHVsZSxcbiAqIGJ1dCBpdCBpbmRlZWQgYnJpbmdzIGNvbnZlbmllbmNlLiBTbyBkbyBub3QgdXNlIHRoZSBtZXRob2RcbiAqIHVubGVzcyB5b3UgZGV0YWlsZWRseSBrbm93IGFsbCB0aGUgaW1wbGVtZW50cyBvZiBgU3ltYm9sYCxcbiAqIGVzcGVjaWFsbHkgYW5pbWF0aW9uLlxuICpcbiAqIEdldCBzeW1ib2wgcGF0aCBlbGVtZW50LlxuICovXG5cblxuc3ltYm9sUHJvdG8uZ2V0U3ltYm9sUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbn07XG4vKipcbiAqIEdldCBzY2FsZShha2EsIGN1cnJlbnQgc3ltYm9sIHNpemUpLlxuICogSW5jbHVkaW5nIHRoZSBjaGFuZ2UgY2F1c2VkIGJ5IGFuaW1hdGlvblxuICovXG5cblxuc3ltYm9sUHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkQXQoMCkuc2NhbGU7XG59O1xuLyoqXG4gKiBIaWdobGlnaHQgc3ltYm9sXG4gKi9cblxuXG5zeW1ib2xQcm90by5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hpbGRBdCgwKS50cmlnZ2VyKCdlbXBoYXNpcycpO1xufTtcbi8qKlxuICogRG93bnBsYXkgc3ltYm9sXG4gKi9cblxuXG5zeW1ib2xQcm90by5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ25vcm1hbCcpO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICogQHBhcmFtIHtudW1iZXJ9IHpcbiAqL1xuXG5cbnN5bWJvbFByb3RvLnNldFogPSBmdW5jdGlvbiAoemxldmVsLCB6KSB7XG4gIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgc3ltYm9sUGF0aC56ID0gejtcbn07XG5cbnN5bWJvbFByb3RvLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gIHN5bWJvbFBhdGguZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICBzeW1ib2xQYXRoLmN1cnNvciA9IGRyYWdnYWJsZSA/ICdtb3ZlJyA6ICdwb2ludGVyJztcbn07XG4vKipcbiAqIFVwZGF0ZSBzeW1ib2wgcHJvcGVydGllc1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLml0ZW1TdHlsZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuaG92ZXJJdGVtU3R5bGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLnN5bWJvbFJvdGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0XVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3Nlcmllc1Njb3BlLmxhYmVsTW9kZWxdXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbc2VyaWVzU2NvcGUuaG92ZXJMYWJlbE1vZGVsXVxuICogQHBhcmFtIHtib29sZWFufSBbc2VyaWVzU2NvcGUuaG92ZXJBbmltYXRpb25dXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLmN1cnNvclN0eWxlXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3Nlcmllc1Njb3BlLml0ZW1Nb2RlbF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VyaWVzU2NvcGUuc3ltYm9sSW5uZXJDb2xvcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuZmFkZUluPWZhbHNlXVxuICovXG5cblxuc3ltYm9sUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIHRoaXMuc2lsZW50ID0gZmFsc2U7XG4gIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG4gIHZhciBpc0luaXQgPSBzeW1ib2xUeXBlICE9PSB0aGlzLl9zeW1ib2xUeXBlO1xuXG4gIGlmIChpc0luaXQpIHtcbiAgICB2YXIga2VlcEFzcGVjdCA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xLZWVwQXNwZWN0Jyk7XG5cbiAgICB0aGlzLl9jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBrZWVwQXNwZWN0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICBzeW1ib2xQYXRoLnNpbGVudCA9IGZhbHNlO1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwge1xuICAgICAgc2NhbGU6IGdldFNjYWxlKHN5bWJvbFNpemUpXG4gICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIH1cblxuICB0aGlzLl91cGRhdGVDb21tb24oZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSk7XG5cbiAgaWYgKGlzSW5pdCkge1xuICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHZhciBmYWRlSW4gPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5mYWRlSW47XG4gICAgdmFyIHRhcmdldCA9IHtcbiAgICAgIHNjYWxlOiBzeW1ib2xQYXRoLnNjYWxlLnNsaWNlKClcbiAgICB9O1xuICAgIGZhZGVJbiAmJiAodGFyZ2V0LnN0eWxlID0ge1xuICAgICAgb3BhY2l0eTogc3ltYm9sUGF0aC5zdHlsZS5vcGFjaXR5XG4gICAgfSk7XG4gICAgc3ltYm9sUGF0aC5zY2FsZSA9IFswLCAwXTtcbiAgICBmYWRlSW4gJiYgKHN5bWJvbFBhdGguc3R5bGUub3BhY2l0eSA9IDApO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIH1cblxuICB0aGlzLl9zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xufTsgLy8gVXBkYXRlIGNvbW1vbiBwcm9wZXJ0aWVzXG5cblxudmFyIG5vcm1hbFN0eWxlQWNjZXNzUGF0aCA9IFsnaXRlbVN0eWxlJ107XG52YXIgZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGggPSBbJ2VtcGhhc2lzJywgJ2l0ZW1TdHlsZSddO1xudmFyIG5vcm1hbExhYmVsQWNjZXNzUGF0aCA9IFsnbGFiZWwnXTtcbnZhciBlbXBoYXNpc0xhYmVsQWNjZXNzUGF0aCA9IFsnZW1waGFzaXMnLCAnbGFiZWwnXTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHN5bWJvbFNpemVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGVdXG4gKi9cblxuc3ltYm9sUHJvdG8uX3VwZGF0ZUNvbW1vbiA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHN5bWJvbFNpemUsIHNlcmllc1Njb3BlKSB7XG4gIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7IC8vIFJlc2V0IHN0eWxlXG5cbiAgaWYgKHN5bWJvbFBhdGgudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoe1xuICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLml0ZW1TdHlsZTtcbiAgdmFyIGhvdmVySXRlbVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJJdGVtU3R5bGU7XG4gIHZhciBzeW1ib2xSb3RhdGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5zeW1ib2xSb3RhdGU7XG4gIHZhciBzeW1ib2xPZmZzZXQgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5zeW1ib2xPZmZzZXQ7XG4gIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGFiZWxNb2RlbDtcbiAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbDtcbiAgdmFyIGhvdmVyQW5pbWF0aW9uID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJBbmltYXRpb247XG4gIHZhciBjdXJzb3JTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmN1cnNvclN0eWxlO1xuXG4gIGlmICghc2VyaWVzU2NvcGUgfHwgZGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLml0ZW1Nb2RlbCA/IHNlcmllc1Njb3BlLml0ZW1Nb2RlbCA6IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7IC8vIENvbG9yIG11c3QgYmUgZXhjbHVkZWQuXG4gICAgLy8gQmVjYXVzZSBzeW1ib2wgcHJvdmlkZSBzZXRDb2xvciBpbmRpdmlkdWFsbHkgdG8gc2V0IGZpbGwgYW5kIHN0cm9rZVxuXG4gICAgaXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKG5vcm1hbFN0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSk7XG4gICAgaG92ZXJJdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGgpLmdldEl0ZW1TdHlsZSgpO1xuICAgIHN5bWJvbFJvdGF0ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xSb3RhdGUnKTtcbiAgICBzeW1ib2xPZmZzZXQgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sT2Zmc2V0Jyk7XG4gICAgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxMYWJlbEFjY2Vzc1BhdGgpO1xuICAgIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChlbXBoYXNpc0xhYmVsQWNjZXNzUGF0aCk7XG4gICAgaG92ZXJBbmltYXRpb24gPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnaG92ZXJBbmltYXRpb24nKTtcbiAgICBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgfSBlbHNlIHtcbiAgICBob3Zlckl0ZW1TdHlsZSA9IHpyVXRpbC5leHRlbmQoe30sIGhvdmVySXRlbVN0eWxlKTtcbiAgfVxuXG4gIHZhciBlbFN0eWxlID0gc3ltYm9sUGF0aC5zdHlsZTtcbiAgc3ltYm9sUGF0aC5hdHRyKCdyb3RhdGlvbicsIChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDApO1xuXG4gIGlmIChzeW1ib2xPZmZzZXQpIHtcbiAgICBzeW1ib2xQYXRoLmF0dHIoJ3Bvc2l0aW9uJywgW3BhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMF0sIHN5bWJvbFNpemVbMF0pLCBwYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzFdLCBzeW1ib2xTaXplWzFdKV0pO1xuICB9XG5cbiAgY3Vyc29yU3R5bGUgJiYgc3ltYm9sUGF0aC5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7IC8vIFBFTkRJTkcgc2V0Q29sb3IgYmVmb3JlIHNldFN0eWxlISEhXG5cbiAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvciwgc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sSW5uZXJDb2xvcik7XG4gIHN5bWJvbFBhdGguc2V0U3R5bGUoaXRlbVN0eWxlKTtcbiAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpO1xuXG4gIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcbiAgICBlbFN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICB9XG5cbiAgdmFyIGxpZnRaID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2xpZnRaJyk7XG4gIHZhciB6Mk9yaWdpbiA9IHN5bWJvbFBhdGguX196Mk9yaWdpbjtcblxuICBpZiAobGlmdFogIT0gbnVsbCkge1xuICAgIGlmICh6Mk9yaWdpbiA9PSBudWxsKSB7XG4gICAgICBzeW1ib2xQYXRoLl9fejJPcmlnaW4gPSBzeW1ib2xQYXRoLnoyO1xuICAgICAgc3ltYm9sUGF0aC56MiArPSBsaWZ0WjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoejJPcmlnaW4gIT0gbnVsbCkge1xuICAgIHN5bWJvbFBhdGguejIgPSB6Mk9yaWdpbjtcbiAgICBzeW1ib2xQYXRoLl9fejJPcmlnaW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIHVzZU5hbWVMYWJlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnVzZU5hbWVMYWJlbDtcbiAgZ3JhcGhpYy5zZXRMYWJlbFN0eWxlKGVsU3R5bGUsIGhvdmVySXRlbVN0eWxlLCBsYWJlbE1vZGVsLCBob3ZlckxhYmVsTW9kZWwsIHtcbiAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgZGVmYXVsdFRleHQ6IGdldExhYmVsRGVmYXVsdFRleHQsXG4gICAgaXNSZWN0VGV4dDogdHJ1ZSxcbiAgICBhdXRvQ29sb3I6IGNvbG9yXG4gIH0pOyAvLyBEbyBub3QgZXhlY3V0ZSB1dGlsIG5lZWRlZC5cblxuICBmdW5jdGlvbiBnZXRMYWJlbERlZmF1bHRUZXh0KGlkeCwgb3B0KSB7XG4gICAgcmV0dXJuIHVzZU5hbWVMYWJlbCA/IGRhdGEuZ2V0TmFtZShpZHgpIDogZ2V0RGVmYXVsdExhYmVsKGRhdGEsIGlkeCk7XG4gIH1cblxuICBzeW1ib2xQYXRoLm9mZignbW91c2VvdmVyJykub2ZmKCdtb3VzZW91dCcpLm9mZignZW1waGFzaXMnKS5vZmYoJ25vcm1hbCcpO1xuICBzeW1ib2xQYXRoLmhvdmVyU3R5bGUgPSBob3Zlckl0ZW1TdHlsZTsgLy8gRklYTUVcbiAgLy8gRG8gbm90IHVzZSBzeW1ib2wudHJpZ2dlcignZW1waGFzaXMnKSwgYnV0IHVzZSBzeW1ib2wuaGlnaGxpZ2h0KCkgaW5zdGVhZC5cblxuICBncmFwaGljLnNldEhvdmVyU3R5bGUoc3ltYm9sUGF0aCk7XG4gIHN5bWJvbFBhdGguX19zeW1ib2xPcmlnaW5hbFNjYWxlID0gZ2V0U2NhbGUoc3ltYm9sU2l6ZSk7XG5cbiAgaWYgKGhvdmVyQW5pbWF0aW9uICYmIHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgLy8gTm90ZTogY29uc2lkZXIgYG9mZmAsIHNob3VsZCB1c2Ugc3RhdGljIGZ1bmN0aW9uIGhlcmUuXG4gICAgc3ltYm9sUGF0aC5vbignbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpLm9uKCdtb3VzZW91dCcsIG9uTW91c2VPdXQpLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpLm9uKCdub3JtYWwnLCBvbk5vcm1hbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9uTW91c2VPdmVyKCkge1xuICAvLyBzZWUgY29tbWVudCBpbiBgZ3JhcGhpYy5pc0luRW1waGFzaXNgXG4gICFncmFwaGljLmlzSW5FbXBoYXNpcyh0aGlzKSAmJiBvbkVtcGhhc2lzLmNhbGwodGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uTW91c2VPdXQoKSB7XG4gIC8vIHNlZSBjb21tZW50IGluIGBncmFwaGljLmlzSW5FbXBoYXNpc2BcbiAgIWdyYXBoaWMuaXNJbkVtcGhhc2lzKHRoaXMpICYmIG9uTm9ybWFsLmNhbGwodGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW1waGFzaXMoKSB7XG4gIC8vIERvIG5vdCBzdXBwb3J0IHRoaXMgaG92ZXIgYW5pbWF0aW9uIHV0aWwgc29tZSBzY2VuYXJpbyByZXF1aXJlZC5cbiAgLy8gQW5pbWF0aW9uIGNhbiBvbmx5IGJlIHN1cHBvcnRlZCBpbiBob3ZlciBsYXllciB3aGVuIHVzaW5nIGBlbC5pbmNyZW1ldGFsYC5cbiAgaWYgKHRoaXMuaW5jcmVtZW50YWwgfHwgdGhpcy51c2VIb3ZlckxheWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gdGhpcy5fX3N5bWJvbE9yaWdpbmFsU2NhbGU7XG4gIHZhciByYXRpbyA9IHNjYWxlWzFdIC8gc2NhbGVbMF07XG4gIHRoaXMuYW5pbWF0ZVRvKHtcbiAgICBzY2FsZTogW01hdGgubWF4KHNjYWxlWzBdICogMS4xLCBzY2FsZVswXSArIDMpLCBNYXRoLm1heChzY2FsZVsxXSAqIDEuMSwgc2NhbGVbMV0gKyAzICogcmF0aW8pXVxuICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG59XG5cbmZ1bmN0aW9uIG9uTm9ybWFsKCkge1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCB8fCB0aGlzLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgc2NhbGU6IHRoaXMuX19zeW1ib2xPcmlnaW5hbFNjYWxlXG4gIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQua2VlcExhYmVsPXRydWVdXG4gKi9cblxuXG5zeW1ib2xQcm90by5mYWRlT3V0ID0gZnVuY3Rpb24gKGNiLCBvcHQpIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7IC8vIEF2b2lkIG1pc3Rha2VuIGhvdmVyIHdoZW4gZmFkaW5nIG91dFxuXG4gIHRoaXMuc2lsZW50ID0gc3ltYm9sUGF0aC5zaWxlbnQgPSB0cnVlOyAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG5cbiAgIShvcHQgJiYgb3B0LmtlZXBMYWJlbCkgJiYgKHN5bWJvbFBhdGguc3R5bGUudGV4dCA9IG51bGwpO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICBzdHlsZToge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgc2NhbGU6IFswLCAwXVxuICB9LCB0aGlzLl9zZXJpZXNNb2RlbCwgdGhpcy5kYXRhSW5kZXgsIGNiKTtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhTeW1ib2xDbHosIGdyYXBoaWMuR3JvdXApO1xudmFyIF9kZWZhdWx0ID0gU3ltYm9sQ2x6O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/helper/Symbol.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/SymbolDraw.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar graphic = __webpack_require__(/*! ../../util/graphic */ \"./node_modules/echarts/lib/util/graphic.js\");\n\nvar SymbolClz = __webpack_require__(/*! ./Symbol */ \"./node_modules/echarts/lib/chart/helper/Symbol.js\");\n\nvar _util = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanM/ZjcwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgU3ltYm9sQ2x6ID0gcmVxdWlyZShcIi4vU3ltYm9sXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sRHJhd1xuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cH0gW3N5bWJvbEN0b3JdXG4gKi9cbmZ1bmN0aW9uIFN5bWJvbERyYXcoc3ltYm9sQ3Rvcikge1xuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgdGhpcy5fc3ltYm9sQ3RvciA9IHN5bWJvbEN0b3IgfHwgU3ltYm9sQ2x6O1xufVxuXG52YXIgc3ltYm9sRHJhd1Byb3RvID0gU3ltYm9sRHJhdy5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgaWR4LCBvcHQpIHtcbiAgcmV0dXJuIHBvaW50ICYmICFpc05hTihwb2ludFswXSkgJiYgIWlzTmFOKHBvaW50WzFdKSAmJiAhKG9wdC5pc0lnbm9yZSAmJiBvcHQuaXNJZ25vcmUoaWR4KSkgLy8gV2UgZG8gbm90IHNldCBjbGlwU2hhcGUgb24gZ3JvdXAsIGJlY2F1c2UgaXQgd2lsbCBjdXQgcGFydCBvZlxuICAvLyB0aGUgc3ltYm9sIGVsZW1lbnQgc2hhcGUuIFdlIHVzZSB0aGUgc2FtZSBjbGlwIHNoYXBlIGhlcmUgYXNcbiAgLy8gdGhlIGxpbmUgY2xpcC5cbiAgJiYgIShvcHQuY2xpcFNoYXBlICYmICFvcHQuY2xpcFNoYXBlLmNvbnRhaW4ocG9pbnRbMF0sIHBvaW50WzFdKSkgJiYgZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpICE9PSAnbm9uZSc7XG59XG4vKipcbiAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF0gT3IgaXNJZ25vcmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHQuaXNJZ25vcmVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5jbGlwU2hhcGVdXG4gKi9cblxuXG5zeW1ib2xEcmF3UHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBvcHQpIHtcbiAgb3B0ID0gbm9ybWFsaXplVXBkYXRlT3B0KG9wdCk7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fc3ltYm9sQ3RvcjtcbiAgdmFyIHNlcmllc1Njb3BlID0gbWFrZVNlcmllc1Njb3BlKGRhdGEpOyAvLyBUaGVyZSBpcyBubyBvbGRMaW5lRGF0YSBvbmx5IHdoZW4gZmlyc3QgcmVuZGVyaW5nIG9yIHN3aXRjaGluZyBmcm9tXG4gIC8vIHN0cmVhbSBtb2RlIHRvIG5vcm1hbCBtb2RlLCB3aGVyZSBwcmV2aW91cyBlbGVtZW50cyBzaG91bGQgYmUgcmVtb3ZlZC5cblxuICBpZiAoIW9sZERhdGEpIHtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgfVxuXG4gIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuXG4gICAgaWYgKHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgbmV3SWR4LCBvcHQpKSB7XG4gICAgICB2YXIgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgIHN5bWJvbEVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICB9XG4gIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICB2YXIgc3ltYm9sRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcblxuICAgIGlmICghc3ltYm9sTmVlZHNEcmF3KGRhdGEsIHBvaW50LCBuZXdJZHgsIG9wdCkpIHtcbiAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgpO1xuICAgICAgc3ltYm9sRWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bWJvbEVsLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbEVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiBwb2ludFxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH0gLy8gQWRkIGJhY2tcblxuXG4gICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgZWwgJiYgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgIH0pO1xuICB9KS5leGVjdXRlKCk7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcblxuc3ltYm9sRHJhd1Byb3RvLmlzUGVyc2lzdGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zeW1ib2xEcmF3UHJvdG8udXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgaWYgKGRhdGEpIHtcbiAgICAvLyBOb3QgdXNlIGFuaW1hdGlvblxuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnN5bWJvbERyYXdQcm90by5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9zZXJpZXNTY29wZSA9IG1ha2VTZXJpZXNTY29wZShkYXRhKTtcbiAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG59O1xuLyoqXG4gKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdIE9yIGlzSWdub3JlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0LmlzSWdub3JlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuY2xpcFNoYXBlXVxuICovXG5cblxuc3ltYm9sRHJhd1Byb3RvLmluY3JlbWVudGFsVXBkYXRlID0gZnVuY3Rpb24gKHRhc2tQYXJhbXMsIGRhdGEsIG9wdCkge1xuICBvcHQgPSBub3JtYWxpemVVcGRhdGVPcHQob3B0KTtcblxuICBmdW5jdGlvbiB1cGRhdGVJbmNyZW1lbnRhbEFuZEhvdmVyKGVsKSB7XG4gICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICBlbC5pbmNyZW1lbnRhbCA9IGVsLnVzZUhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IHRhc2tQYXJhbXMuc3RhcnQ7IGlkeCA8IHRhc2tQYXJhbXMuZW5kOyBpZHgrKykge1xuICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgaWYgKHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgaWR4LCBvcHQpKSB7XG4gICAgICB2YXIgZWwgPSBuZXcgdGhpcy5fc3ltYm9sQ3RvcihkYXRhLCBpZHgsIHRoaXMuX3Nlcmllc1Njb3BlKTtcbiAgICAgIGVsLnRyYXZlcnNlKHVwZGF0ZUluY3JlbWVudGFsQW5kSG92ZXIpO1xuICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgICB0aGlzLmdyb3VwLmFkZChlbCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBlbCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVVcGRhdGVPcHQob3B0KSB7XG4gIGlmIChvcHQgIT0gbnVsbCAmJiAhaXNPYmplY3Qob3B0KSkge1xuICAgIG9wdCA9IHtcbiAgICAgIGlzSWdub3JlOiBvcHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG9wdCB8fCB7fTtcbn1cblxuc3ltYm9sRHJhd1Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbmFibGVBbmltYXRpb24pIHtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhOyAvLyBJbmNyZW1lbnRhbCBtb2RlbCBkbyBub3QgaGF2ZSB0aGlzLl9kYXRhLlxuXG4gIGlmIChkYXRhICYmIGVuYWJsZUFuaW1hdGlvbikge1xuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlU2VyaWVzU2NvcGUoZGF0YSkge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgcmV0dXJuIHtcbiAgICBpdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKSxcbiAgICBob3Zlckl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzLml0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpLFxuICAgIHN5bWJvbFJvdGF0ZTogc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2xSb3RhdGUnKSxcbiAgICBzeW1ib2xPZmZzZXQ6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sT2Zmc2V0JyksXG4gICAgaG92ZXJBbmltYXRpb246IHNlcmllc01vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSxcbiAgICBsYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKSxcbiAgICBob3ZlckxhYmVsTW9kZWw6IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbXBoYXNpcy5sYWJlbCcpLFxuICAgIGN1cnNvclN0eWxlOiBzZXJpZXNNb2RlbC5nZXQoJ2N1cnNvcicpXG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IFN5bWJvbERyYXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line.js":
/*!************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = __webpack_require__(/*! ../echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\n__webpack_require__(/*! ./line/LineSeries */ \"./node_modules/echarts/lib/chart/line/LineSeries.js\");\n\n__webpack_require__(/*! ./line/LineView */ \"./node_modules/echarts/lib/chart/line/LineView.js\");\n\nvar visualSymbol = __webpack_require__(/*! ../visual/symbol */ \"./node_modules/echarts/lib/visual/symbol.js\");\n\nvar layoutPoints = __webpack_require__(/*! ../layout/points */ \"./node_modules/echarts/lib/layout/points.js\");\n\nvar dataSample = __webpack_require__(/*! ../processor/dataSample */ \"./node_modules/echarts/lib/processor/dataSample.js\");\n\n__webpack_require__(/*! ../component/gridSimple */ \"./node_modules/echarts/lib/component/gridSimple.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lLmpzP2VmOTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnJlcXVpcmUoXCIuL2xpbmUvTGluZVNlcmllc1wiKTtcblxucmVxdWlyZShcIi4vbGluZS9MaW5lVmlld1wiKTtcblxudmFyIHZpc3VhbFN5bWJvbCA9IHJlcXVpcmUoXCIuLi92aXN1YWwvc3ltYm9sXCIpO1xuXG52YXIgbGF5b3V0UG9pbnRzID0gcmVxdWlyZShcIi4uL2xheW91dC9wb2ludHNcIik7XG5cbnZhciBkYXRhU2FtcGxlID0gcmVxdWlyZShcIi4uL3Byb2Nlc3Nvci9kYXRhU2FtcGxlXCIpO1xuXG5yZXF1aXJlKFwiLi4vY29tcG9uZW50L2dyaWRTaW1wbGVcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEluIGNhc2UgZGV2ZWxvcGVyIGZvcmdldCB0byBpbmNsdWRlIGdyaWQgY29tcG9uZW50XG5lY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHZpc3VhbFN5bWJvbCgnbGluZScsICdjaXJjbGUnLCAnbGluZScpKTtcbmVjaGFydHMucmVnaXN0ZXJMYXlvdXQobGF5b3V0UG9pbnRzKCdsaW5lJykpOyAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcblxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihlY2hhcnRzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIGRhdGFTYW1wbGUoJ2xpbmUnKSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineSeries.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/LineSeries.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = __webpack_require__(/*! ../../config */ \"./node_modules/echarts/lib/config.js\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ \"./node_modules/echarts/lib/chart/helper/createListFromArray.js\");\n\nvar SeriesModel = __webpack_require__(/*! ../../model/Series */ \"./node_modules/echarts/lib/model/Series.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qcz8yMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheVwiKTtcblxudmFyIFNlcmllc01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL1Nlcmllc1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ3Nlcmllcy5saW5lJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcbiAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheSh0aGlzLmdldFNvdXJjZSgpLCB0aGlzKTtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGhvdmVyQW5pbWF0aW9uOiB0cnVlLFxuICAgIC8vIHN0YWNrOiBudWxsXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIC8vIHBvbGFySW5kZXg6IDAsXG4gICAgLy8gSWYgY2xpcCB0aGUgb3ZlcmZsb3cgdmFsdWVcbiAgICBjbGlwT3ZlcmZsb3c6IHRydWUsXG4gICAgLy8gY3Vyc29yOiBudWxsLFxuICAgIGxhYmVsOiB7XG4gICAgICBwb3NpdGlvbjogJ3RvcCdcbiAgICB9LFxuICAgIC8vIGl0ZW1TdHlsZToge1xuICAgIC8vIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICB3aWR0aDogMixcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIC8vIGFyZWFTdHlsZToge1xuICAgIC8vIG9yaWdpbiBvZiBhcmVhU3R5bGUuIFZhbGlkIHZhbHVlczpcbiAgICAvLyBgJ2F1dG8nL251bGwvdW5kZWZpbmVkYDogZnJvbSBheGlzTGluZSB0byBkYXRhXG4gICAgLy8gYCdzdGFydCdgOiBmcm9tIG1pbiB0byBkYXRhXG4gICAgLy8gYCdlbmQnYDogZnJvbSBkYXRhIHRvIG1heFxuICAgIC8vIG9yaWdpbjogJ2F1dG8nXG4gICAgLy8gfSxcbiAgICAvLyBmYWxzZSwgJ3N0YXJ0JywgJ2VuZCcsICdtaWRkbGUnXG4gICAgc3RlcDogZmFsc2UsXG4gICAgLy8gRGlzYWJsZWQgaWYgc3RlcCBpcyB0cnVlXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhNb25vdG9uZTogbnVsbCxcbiAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgc3ltYm9sU2l6ZTogNCxcbiAgICBzeW1ib2xSb3RhdGU6IG51bGwsXG4gICAgc2hvd1N5bWJvbDogdHJ1ZSxcbiAgICAvLyBgZmFsc2VgOiBmb2xsb3cgdGhlIGxhYmVsIGludGVydmFsIHN0cmF0ZWd5LlxuICAgIC8vIGB0cnVlYDogc2hvdyBhbGwgc3ltYm9scy5cbiAgICAvLyBgJ2F1dG8nYDogSWYgcG9zc2libGUsIHNob3cgYWxsIHN5bWJvbHMsIG90aGVyd2lzZVxuICAgIC8vICAgICAgICAgICBmb2xsb3cgdGhlIGxhYmVsIGludGVydmFsIHN0cmF0ZWd5LlxuICAgIHNob3dBbGxTeW1ib2w6ICdhdXRvJyxcbiAgICAvLyBXaGV0aGVyIHRvIGNvbm5lY3QgYnJlYWsgcG9pbnQuXG4gICAgY29ubmVjdE51bGxzOiBmYWxzZSxcbiAgICAvLyBTYW1wbGluZyBmb3IgbGFyZ2UgZGF0YS4gQ2FuIGJlOiAnYXZlcmFnZScsICdtYXgnLCAnbWluJywgJ3N1bScuXG4gICAgc2FtcGxpbmc6ICdub25lJyxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuICAgIC8vIERpc2FibGUgcHJvZ3Jlc3NpdmVcbiAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICBob3ZlckxheWVyVGhyZXNob2xkOiBJbmZpbml0eVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line/LineSeries.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineView.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/LineView.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = __webpack_require__(/*! ../../config */ \"./node_modules/echarts/lib/config.js\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ \"./node_modules/echarts/lib/chart/helper/SymbolDraw.js\");\n\nvar SymbolClz = __webpack_require__(/*! ../helper/Symbol */ \"./node_modules/echarts/lib/chart/helper/Symbol.js\");\n\nvar lineAnimationDiff = __webpack_require__(/*! ./lineAnimationDiff */ \"./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\");\n\nvar graphic = __webpack_require__(/*! ../../util/graphic */ \"./node_modules/echarts/lib/util/graphic.js\");\n\nvar modelUtil = __webpack_require__(/*! ../../util/model */ \"./node_modules/echarts/lib/util/model.js\");\n\nvar _poly = __webpack_require__(/*! ./poly */ \"./node_modules/echarts/lib/chart/line/poly.js\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(/*! ../../view/Chart */ \"./node_modules/echarts/lib/view/Chart.js\");\n\nvar _number = __webpack_require__(/*! ../../util/number */ \"./node_modules/echarts/lib/util/number.js\");\n\nvar round = _number.round;\n\nvar _helper = __webpack_require__(/*! ./helper */ \"./node_modules/echarts/lib/chart/line/helper.js\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.\n  // See #7913 and `test/dataZoom-clip.html`.\n\n  if (forSymbol) {\n    x -= 0.5;\n    width += 0.5;\n    y -= 0.5;\n    height += 0.5;\n  } else {\n    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n    if (isHorizontal) {\n      y -= expandSize;\n      height += expandSize * 2;\n    } else {\n      x -= expandSize;\n      width += expandSize * 2;\n    }\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent().slice();\n  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  if (forSymbol) {\n    radiusExtent[0] -= 0.5;\n    radiusExtent[1] += 0.5;\n  }\n\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: round(polar.cx, 1),\n      cy: round(polar.cy, 1),\n      r0: round(radiusExtent[0], 1),\n      r: round(radiusExtent[1], 1),\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {\n    labelMap[labelItem.tickValue] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lVmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzP2YxN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU3ltYm9sRHJhdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvU3ltYm9sRHJhd1wiKTtcblxudmFyIFN5bWJvbENseiA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvU3ltYm9sXCIpO1xuXG52YXIgbGluZUFuaW1hdGlvbkRpZmYgPSByZXF1aXJlKFwiLi9saW5lQW5pbWF0aW9uRGlmZlwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBfcG9seSA9IHJlcXVpcmUoXCIuL3BvbHlcIik7XG5cbnZhciBQb2x5bGluZSA9IF9wb2x5LlBvbHlsaW5lO1xudmFyIFBvbHlnb24gPSBfcG9seS5Qb2x5Z29uO1xuXG52YXIgQ2hhcnRWaWV3ID0gcmVxdWlyZShcIi4uLy4uL3ZpZXcvQ2hhcnRcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgcm91bmQgPSBfbnVtYmVyLnJvdW5kO1xuXG52YXIgX2hlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIHByZXBhcmVEYXRhQ29vcmRJbmZvID0gX2hlbHBlci5wcmVwYXJlRGF0YUNvb3JkSW5mbztcbnZhciBnZXRTdGFja2VkT25Qb2ludCA9IF9oZWxwZXIuZ2V0U3RhY2tlZE9uUG9pbnQ7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEZJWE1FIHN0ZXAgbm90IHN1cHBvcnQgcG9sYXJcbmZ1bmN0aW9uIGlzUG9pbnRzU2FtZShwb2ludHMxLCBwb2ludHMyKSB7XG4gIGlmIChwb2ludHMxLmxlbmd0aCAhPT0gcG9pbnRzMi5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcDEgPSBwb2ludHMxW2ldO1xuICAgIHZhciBwMiA9IHBvaW50czJbaV07XG5cbiAgICBpZiAocDFbMF0gIT09IHAyWzBdIHx8IHAxWzFdICE9PSBwMlsxXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRTbW9vdGgoc21vb3RoKSB7XG4gIHJldHVybiB0eXBlb2Ygc21vb3RoID09PSAnbnVtYmVyJyA/IHNtb290aCA6IHNtb290aCA/IDAuNSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNFeHRlbnRXaXRoR2FwKGF4aXMpIHtcbiAgdmFyIGV4dGVudCA9IGF4aXMuZ2V0R2xvYmFsRXh0ZW50KCk7XG5cbiAgaWYgKGF4aXMub25CYW5kKSB7XG4gICAgLy8gUmVtb3ZlIGV4dHJhIDFweCB0byBhdm9pZCBsaW5lIG1pdGVyIGluIGNsaXBwZWQgZWRnZVxuICAgIHZhciBoYWxmQmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKSAvIDIgLSAxO1xuICAgIHZhciBkaXIgPSBleHRlbnRbMV0gPiBleHRlbnRbMF0gPyAxIDogLTE7XG4gICAgZXh0ZW50WzBdICs9IGRpciAqIGhhbGZCYW5kV2lkdGg7XG4gICAgZXh0ZW50WzFdIC09IGRpciAqIGhhbGZCYW5kV2lkdGg7XG4gIH1cblxuICByZXR1cm4gZXh0ZW50O1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRHxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9wb2xhci9Qb2xhcn0gY29vcmRTeXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YUNvb3JkSW5mb1xuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSwgZGF0YUNvb3JkSW5mbykge1xuICBpZiAoIWRhdGFDb29yZEluZm8udmFsdWVEaW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaWR4ID0gMCwgbGVuID0gZGF0YS5jb3VudCgpOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgcG9pbnRzLnB1c2goZ2V0U3RhY2tlZE9uUG9pbnQoZGF0YUNvb3JkSW5mbywgY29vcmRTeXMsIGRhdGEsIGlkeCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JpZENsaXBTaGFwZShjYXJ0ZXNpYW4sIGhhc0FuaW1hdGlvbiwgZm9yU3ltYm9sLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgeEV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd4JykpO1xuICB2YXIgeUV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd5JykpO1xuICB2YXIgaXNIb3Jpem9udGFsID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCk7XG4gIHZhciB4ID0gTWF0aC5taW4oeEV4dGVudFswXSwgeEV4dGVudFsxXSk7XG4gIHZhciB5ID0gTWF0aC5taW4oeUV4dGVudFswXSwgeUV4dGVudFsxXSk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pIC0geDtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pIC0geTsgLy8gQXZvaWQgZmxvYXQgbnVtYmVyIHJvdW5kaW5nIGVycm9yIGZvciBzeW1ib2wgb24gdGhlIGVkZ2Ugb2YgYXhpcyBleHRlbnQuXG4gIC8vIFNlZSAjNzkxMyBhbmQgYHRlc3QvZGF0YVpvb20tY2xpcC5odG1sYC5cblxuICBpZiAoZm9yU3ltYm9sKSB7XG4gICAgeCAtPSAwLjU7XG4gICAgd2lkdGggKz0gMC41O1xuICAgIHkgLT0gMC41O1xuICAgIGhlaWdodCArPSAwLjU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHNlcmllc01vZGVsLmdldCgnbGluZVN0eWxlLndpZHRoJykgfHwgMjsgLy8gRXhwYW5kIGNsaXAgc2hhcGUgdG8gYXZvaWQgY2xpcHBpbmcgd2hlbiBsaW5lIHZhbHVlIGV4Y2VlZHMgYXhpc1xuXG4gICAgdmFyIGV4cGFuZFNpemUgPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXBPdmVyZmxvdycpID8gbGluZVdpZHRoIC8gMiA6IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgeSAtPSBleHBhbmRTaXplO1xuICAgICAgaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB4IC09IGV4cGFuZFNpemU7XG4gICAgICB3aWR0aCArPSBleHBhbmRTaXplICogMjtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzaGFwZToge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgIGNsaXBQYXRoLnNoYXBlW2lzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gPSAwO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwpO1xuICB9XG5cbiAgcmV0dXJuIGNsaXBQYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2xhckNsaXBTaGFwZShwb2xhciwgaGFzQW5pbWF0aW9uLCBmb3JTeW1ib2wsIHNlcmllc01vZGVsKSB7XG4gIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgdmFyIHJhZGl1c0F4aXMgPSBwb2xhci5nZXRSYWRpdXNBeGlzKCk7XG4gIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpLnNsaWNlKCk7XG4gIHJhZGl1c0V4dGVudFswXSA+IHJhZGl1c0V4dGVudFsxXSAmJiByYWRpdXNFeHRlbnQucmV2ZXJzZSgpO1xuICB2YXIgYW5nbGVFeHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwOyAvLyBBdm9pZCBmbG9hdCBudW1iZXIgcm91bmRpbmcgZXJyb3IgZm9yIHN5bWJvbCBvbiB0aGUgZWRnZSBvZiBheGlzIGV4dGVudC5cblxuICBpZiAoZm9yU3ltYm9sKSB7XG4gICAgcmFkaXVzRXh0ZW50WzBdIC09IDAuNTtcbiAgICByYWRpdXNFeHRlbnRbMV0gKz0gMC41O1xuICB9XG5cbiAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICBzaGFwZToge1xuICAgICAgY3g6IHJvdW5kKHBvbGFyLmN4LCAxKSxcbiAgICAgIGN5OiByb3VuZChwb2xhci5jeSwgMSksXG4gICAgICByMDogcm91bmQocmFkaXVzRXh0ZW50WzBdLCAxKSxcbiAgICAgIHI6IHJvdW5kKHJhZGl1c0V4dGVudFsxXSwgMSksXG4gICAgICBzdGFydEFuZ2xlOiAtYW5nbGVFeHRlbnRbMF0gKiBSQURJQU4sXG4gICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOLFxuICAgICAgY2xvY2t3aXNlOiBhbmdsZUF4aXMuaW52ZXJzZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgIGNsaXBQYXRoLnNoYXBlLmVuZEFuZ2xlID0gLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOXG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwpO1xuICB9XG5cbiAgcmV0dXJuIGNsaXBQYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgZm9yU3ltYm9sLCBzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJyA/IGNyZWF0ZVBvbGFyQ2xpcFNoYXBlKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIGZvclN5bWJvbCwgc2VyaWVzTW9kZWwpIDogY3JlYXRlR3JpZENsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBmb3JTeW1ib2wsIHNlcmllc01vZGVsKTtcbn1cblxuZnVuY3Rpb24gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXBUdXJuQXQpIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIGJhc2VJbmRleCA9IGJhc2VBeGlzLmRpbSA9PT0gJ3gnIHx8IGJhc2VBeGlzLmRpbSA9PT0gJ3JhZGl1cycgPyAwIDogMTtcbiAgdmFyIHN0ZXBQb2ludHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgbmV4dFB0ID0gcG9pbnRzW2kgKyAxXTtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgc3RlcFBvaW50cy5wdXNoKHB0KTtcbiAgICB2YXIgc3RlcFB0ID0gW107XG5cbiAgICBzd2l0Y2ggKHN0ZXBUdXJuQXQpIHtcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gbmV4dFB0W2Jhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdOyAvLyBkZWZhdWx0IGlzIHN0YXJ0XG5cbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAvLyBkZWZhdWx0IGlzIHN0YXJ0XG4gICAgICAgIHZhciBtaWRkbGUgPSAocHRbYmFzZUluZGV4XSArIG5leHRQdFtiYXNlSW5kZXhdKSAvIDI7XG4gICAgICAgIHZhciBzdGVwUHQyID0gW107XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gc3RlcFB0MltiYXNlSW5kZXhdID0gbWlkZGxlO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFB0MlsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gcHRbYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gbmV4dFB0WzEgLSBiYXNlSW5kZXhdOyAvLyBkZWZhdWx0IGlzIHN0YXJ0XG5cbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgfVxuICB9IC8vIExhc3QgcG9pbnRzXG5cblxuICBwb2ludHNbaV0gJiYgc3RlcFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XG4gIHJldHVybiBzdGVwUG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykge1xuICB2YXIgdmlzdWFsTWV0YUxpc3QgPSBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpO1xuXG4gIGlmICghdmlzdWFsTWV0YUxpc3QgfHwgIXZpc3VhbE1ldGFMaXN0Lmxlbmd0aCB8fCAhZGF0YS5jb3VudCgpKSB7XG4gICAgLy8gV2hlbiBkYXRhLmNvdW50KCkgaXMgMCwgZ3JhZGllbnQgcmFuZ2UgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvb3JkRGltO1xuICB2YXIgdmlzdWFsTWV0YTtcblxuICBmb3IgKHZhciBpID0gdmlzdWFsTWV0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZGltSW5kZXggPSB2aXN1YWxNZXRhTGlzdFtpXS5kaW1lbnNpb247XG4gICAgdmFyIGRpbU5hbWUgPSBkYXRhLmRpbWVuc2lvbnNbZGltSW5kZXhdO1xuICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuICAgIGNvb3JkRGltID0gZGltSW5mbyAmJiBkaW1JbmZvLmNvb3JkRGltOyAvLyBDYW4gb25seSBiZSB4IG9yIHlcblxuICAgIGlmIChjb29yZERpbSA9PT0gJ3gnIHx8IGNvb3JkRGltID09PSAneScpIHtcbiAgICAgIHZpc3VhbE1ldGEgPSB2aXN1YWxNZXRhTGlzdFtpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmlzdWFsTWV0YSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiB0aGUgYXJlYSB0byBiZSByZW5kZXJlZCBpcyBiaWdnZXIgdGhhbiBhcmVhIGRlZmluZWQgYnkgTGluZWFyR3JhZGllbnQsXG4gIC8vIHRoZSBjYW52YXMgc3BlYyBwcmVzY3JpYmVzIHRoYXQgdGhlIGNvbG9yIG9mIHRoZSBmaXJzdCBzdG9wIGFuZCB0aGUgbGFzdFxuICAvLyBzdG9wIHNob3VsZCBiZSB1c2VkLiBCdXQgaWYgdHdvIHN0b3BzIGFyZSBhZGRlZCBhdCBvZmZzZXQgMCwgaW4gZWZmZWN0XG4gIC8vIGJyb3dzZXJzIHVzZSB0aGUgY29sb3Igb2YgdGhlIHNlY29uZCBzdG9wIHRvIHJlbmRlciBhcmVhIG91dHNpZGVcbiAgLy8gTGluZWFyR3JhZGllbnQuIFNvIHdlIGNhbiBvbmx5IGluZmluaXRlc2ltYWxseSBleHRlbmQgYXJlYSBkZWZpbmVkIGluXG4gIC8vIExpbmVhckdyYWRpZW50IHRvIHJlbmRlciBgb3V0ZXJDb2xvcnNgLlxuXG5cbiAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGNvb3JkRGltKTsgLy8gZGF0YVRvQ29vciBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG5cbiAgdmFyIGNvbG9yU3RvcHMgPSB6clV0aWwubWFwKHZpc3VhbE1ldGEuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICBjb2xvcjogc3RvcC5jb2xvclxuICAgIH07XG4gIH0pO1xuICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG5cbiAgaWYgKHN0b3BMZW4gJiYgY29sb3JTdG9wc1swXS5jb29yZCA+IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkKSB7XG4gICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgb3V0ZXJDb2xvcnMucmV2ZXJzZSgpO1xuICB9XG5cbiAgdmFyIHRpbnlFeHRlbnQgPSAxMDsgLy8gQXJiaXRyYXJ5IHZhbHVlOiAxMHB4XG5cbiAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc1swXS5jb29yZCAtIHRpbnlFeHRlbnQ7XG4gIHZhciBtYXhDb29yZCA9IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG5cbiAgaWYgKGNvb3JkU3BhbiA8IDFlLTMpIHtcbiAgICByZXR1cm4gJ3RyYW5zcGFyZW50JztcbiAgfVxuXG4gIHpyVXRpbC5lYWNoKGNvbG9yU3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgfSk7XG4gIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0ub2Zmc2V0IDogMC41LFxuICAgIGNvbG9yOiBvdXRlckNvbG9yc1sxXSB8fCAndHJhbnNwYXJlbnQnXG4gIH0pO1xuICBjb2xvclN0b3BzLnVuc2hpZnQoe1xuICAgIC8vIG5vdGljZSBjb2xvclN0b3BzLmxlbmd0aCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICBvZmZzZXQ6IHN0b3BMZW4gPyBjb2xvclN0b3BzWzBdLm9mZnNldCA6IDAuNSxcbiAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMF0gfHwgJ3RyYW5zcGFyZW50J1xuICB9KTsgLy8genJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKGNvbG9yU3RvcCkge1xuICAvLyAgICAgLy8gTWFrZSBzdXJlIGVhY2ggb2Zmc2V0IGhhcyByb3VuZGVkIHB4IHRvIGF2b2lkIG5vdCBzaGFycCBlZGdlXG4gIC8vICAgICBjb2xvclN0b3Aub2Zmc2V0ID0gKE1hdGgucm91bmQoY29sb3JTdG9wLm9mZnNldCAqIChlbmQgLSBzdGFydCkgKyBzdGFydCkgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xuICAvLyB9KTtcblxuICB2YXIgZ3JhZGllbnQgPSBuZXcgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAwLCBjb2xvclN0b3BzLCB0cnVlKTtcbiAgZ3JhZGllbnRbY29vcmREaW1dID0gbWluQ29vcmQ7XG4gIGdyYWRpZW50W2Nvb3JkRGltICsgJzInXSA9IG1heENvb3JkO1xuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGdldElzSWdub3JlRnVuYyhzZXJpZXNNb2RlbCwgZGF0YSwgY29vcmRTeXMpIHtcbiAgdmFyIHNob3dBbGxTeW1ib2wgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dBbGxTeW1ib2wnKTtcbiAgdmFyIGlzQXV0byA9IHNob3dBbGxTeW1ib2wgPT09ICdhdXRvJztcblxuICBpZiAoc2hvd0FsbFN5bWJvbCAmJiAhaXNBdXRvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG5cbiAgaWYgKCFjYXRlZ29yeUF4aXMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGF0IGNhdGVnb3J5IGxhYmVsIGludGVydmFsIHN0cmF0ZWd5IG1pZ2h0IGJyaW5nIHNvbWUgd2VpcmQgZWZmZWN0XG4gIC8vIGluIHNvbWUgc2NlbmFyaW86IHVzZXJzIG1heSB3b25kZXIgd2h5IHNvbWUgb2YgdGhlIHN5bWJvbHMgYXJlIG5vdFxuICAvLyBkaXNwbGF5ZWQuIFNvIHdlIHNob3cgYWxsIHN5bWJvbHMgYXMgcG9zc2libGUgYXMgd2UgY2FuLlxuXG5cbiAgaWYgKGlzQXV0byAvLyBTaW1wbGlmeSB0aGUgbG9naWMsIGRvIG5vdCBkZXRlcm1pbmUgbGFiZWwgb3ZlcmxhcCBoZXJlLlxuICAmJiBjYW5TaG93QWxsU3ltYm9sRm9yQ2F0ZWdvcnkoY2F0ZWdvcnlBeGlzLCBkYXRhKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBPdGhlcndpc2UgZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneSBvbiBjYXRlZ29yeSBheGlzLlxuXG5cbiAgdmFyIGNhdGVnb3J5RGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKGNhdGVnb3J5QXhpcy5kaW0pO1xuICB2YXIgbGFiZWxNYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goY2F0ZWdvcnlBeGlzLmdldFZpZXdMYWJlbHMoKSwgZnVuY3Rpb24gKGxhYmVsSXRlbSkge1xuICAgIGxhYmVsTWFwW2xhYmVsSXRlbS50aWNrVmFsdWVdID0gMTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgcmV0dXJuICFsYWJlbE1hcC5oYXNPd25Qcm9wZXJ0eShkYXRhLmdldChjYXRlZ29yeURhdGFEaW0sIGRhdGFJbmRleCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYW5TaG93QWxsU3ltYm9sRm9yQ2F0ZWdvcnkoY2F0ZWdvcnlBeGlzLCBkYXRhKSB7XG4gIC8vIEluIG1vc2UgY2FzZXMsIGxpbmUgaXMgbW9ub3Rvbm91cyBvbiBjYXRlZ29yeSBheGlzLCBhbmQgdGhlIGxhYmVsIHNpemVcbiAgLy8gaXMgY2xvc2Ugd2l0aCBlYWNoIG90aGVyLiBTbyB3ZSBjaGVjayB0aGUgc3ltYm9sIHNpemUgYW5kIHNvbWUgb2YgdGhlXG4gIC8vIGxhYmVsIHNpemUgYWxvbmUgd2l0aCB0aGUgY2F0ZWdvcnkgYXhpcyB0byBlc3RpbWF0ZSB3aGV0aGVyIGFsbCBzeW1ib2xcbiAgLy8gY2FuIGJlIHNob3duIHdpdGhvdXQgb3ZlcmxhcC5cbiAgdmFyIGF4aXNFeHRlbnQgPSBjYXRlZ29yeUF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBhdmFpbFNpemUgPSBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSkgLyBjYXRlZ29yeUF4aXMuc2NhbGUuY291bnQoKTtcbiAgaXNOYU4oYXZhaWxTaXplKSAmJiAoYXZhaWxTaXplID0gMCk7IC8vIDAvMCBpcyBOYU4uXG4gIC8vIFNhbXBsaW5nIHNvbWUgcG9pbnRzLCBtYXggNS5cblxuICB2YXIgZGF0YUxlbiA9IGRhdGEuY291bnQoKTtcbiAgdmFyIHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGRhdGFMZW4gLyA1KSk7XG5cbiAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YUxlbjsgZGF0YUluZGV4ICs9IHN0ZXApIHtcbiAgICBpZiAoU3ltYm9sQ2x6LmdldFN5bWJvbFNpemUoZGF0YSwgZGF0YUluZGV4IC8vIE9ubHkgZm9yIGNhcnRlc2lhbiwgd2hlcmUgYGlzSG9yaXpvbnRhbGAgZXhpc3RzLlxuICAgIClbY2F0ZWdvcnlBeGlzLmlzSG9yaXpvbnRhbCgpID8gMSA6IDBdIC8vIEVtcGlyaWNhbCBudW1iZXJcbiAgICAqIDEuNSA+IGF2YWlsU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2RlZmF1bHQgPSBDaGFydFZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2xpbmUnLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuICAgIHRoaXMuX3N5bWJvbERyYXcgPSBzeW1ib2xEcmF3O1xuICAgIHRoaXMuX2xpbmVHcm91cCA9IGxpbmVHcm91cDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBwb2ludHMgPSBkYXRhLm1hcEFycmF5KGRhdGEuZ2V0SXRlbUxheW91dCk7XG4gICAgdmFyIGlzQ29vcmRTeXNQb2xhciA9IGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcic7XG4gICAgdmFyIHByZXZDb29yZFN5cyA9IHRoaXMuX2Nvb3JkU3lzO1xuICAgIHZhciBzeW1ib2xEcmF3ID0gdGhpcy5fc3ltYm9sRHJhdztcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgdmFyIGxpbmVHcm91cCA9IHRoaXMuX2xpbmVHcm91cDtcbiAgICB2YXIgaGFzQW5pbWF0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICB2YXIgaXNBcmVhQ2hhcnQgPSAhYXJlYVN0eWxlTW9kZWwuaXNFbXB0eSgpO1xuICAgIHZhciB2YWx1ZU9yaWdpbiA9IGFyZWFTdHlsZU1vZGVsLmdldCgnb3JpZ2luJyk7XG4gICAgdmFyIGRhdGFDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbyhjb29yZFN5cywgZGF0YSwgdmFsdWVPcmlnaW4pO1xuICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEsIGRhdGFDb29yZEluZm8pO1xuICAgIHZhciBzaG93U3ltYm9sID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93U3ltYm9sJyk7XG4gICAgdmFyIGlzSWdub3JlRnVuYyA9IHNob3dTeW1ib2wgJiYgIWlzQ29vcmRTeXNQb2xhciAmJiBnZXRJc0lnbm9yZUZ1bmMoc2VyaWVzTW9kZWwsIGRhdGEsIGNvb3JkU3lzKTsgLy8gUmVtb3ZlIHRlbXBvcmFyeSBzeW1ib2xzXG5cbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pOyAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBzeW1ib2xzIGlmIHNob3dTeW1ib2wgY2hhbmdlZCB0byBmYWxzZVxuXG4gICAgaWYgKCFzaG93U3ltYm9sKSB7XG4gICAgICBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGdyb3VwLmFkZChsaW5lR3JvdXApOyAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5cbiAgICB2YXIgc3RlcCA9ICFpc0Nvb3JkU3lzUG9sYXIgJiYgc2VyaWVzTW9kZWwuZ2V0KCdzdGVwJyk7IC8vIEluaXRpYWxpemF0aW9uIGFuaW1hdGlvbiBvciBjb29yZGluYXRlIHN5c3RlbSBjaGFuZ2VkXG5cbiAgICBpZiAoIShwb2x5bGluZSAmJiBwcmV2Q29vcmRTeXMudHlwZSA9PT0gY29vcmRTeXMudHlwZSAmJiBzdGVwID09PSB0aGlzLl9zdGVwKSkge1xuICAgICAgc2hvd1N5bWJvbCAmJiBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSwge1xuICAgICAgICBpc0lnbm9yZTogaXNJZ25vcmVGdW5jLFxuICAgICAgICBjbGlwU2hhcGU6IGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgZmFsc2UsIHRydWUsIHNlcmllc01vZGVsKVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHBvbHlsaW5lID0gdGhpcy5fbmV3UG9seWxpbmUocG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcblxuICAgICAgaWYgKGlzQXJlYUNoYXJ0KSB7XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9uZXdQb2x5Z29uKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgdHJ1ZSwgZmFsc2UsIHNlcmllc01vZGVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FyZWFDaGFydCAmJiAhcG9seWdvbikge1xuICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgYWRkZWRcbiAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24ocG9pbnRzLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBoYXNBbmltYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChwb2x5Z29uICYmICFpc0FyZWFDaGFydCkge1xuICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgcmVtb3ZlZFxuICAgICAgICBsaW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uID0gdGhpcy5fcG9seWdvbiA9IG51bGw7XG4gICAgICB9IC8vIFVwZGF0ZSBjbGlwUGF0aFxuXG5cbiAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGZhbHNlLCBmYWxzZSwgc2VyaWVzTW9kZWwpKTsgLy8gQWx3YXlzIHVwZGF0ZSwgb3IgaXQgaXMgd3JvbmcgaW4gdGhlIGNhc2UgdHVybmluZyBvbiBsZWdlbmRcbiAgICAgIC8vIGJlY2F1c2UgcG9pbnRzIGFyZSBub3QgY2hhbmdlZFxuXG4gICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCB7XG4gICAgICAgIGlzSWdub3JlOiBpc0lnbm9yZUZ1bmMsXG4gICAgICAgIGNsaXBTaGFwZTogY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCBmYWxzZSwgdHJ1ZSwgc2VyaWVzTW9kZWwpXG4gICAgICB9KTsgLy8gU3RvcCBzeW1ib2wgYW5pbWF0aW9uIGFuZCBzeW5jIHdpdGggbGluZSBwb2ludHNcbiAgICAgIC8vIEZJWE1FIHBlcmZvcm1hbmNlP1xuXG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgfSk7IC8vIEluIHRoZSBjYXNlIGRhdGEgem9vbSB0cmlnZ2VycmVkIHJlZnJlc2hpbmcgZnJlcXVlbnRseVxuICAgICAgLy8gRGF0YSBtYXkgbm90IGNoYW5nZSBpZiBsaW5lIGhhcyBhIGNhdGVnb3J5IGF4aXMuIFNvIGl0IHNob3VsZCBhbmltYXRlIG5vdGhpbmdcblxuICAgICAgaWYgKCFpc1BvaW50c1NhbWUodGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMpIHx8ICFpc1BvaW50c1NhbWUodGhpcy5fcG9pbnRzLCBwb2ludHMpKSB7XG4gICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRpb24oZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwLCB2YWx1ZU9yaWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm90IGRvIGl0IGluIHVwZGF0ZSB3aXRoIGFuaW1hdGlvblxuICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICBwb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb2x5Z29uICYmIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpc3VhbENvbG9yID0gZ2V0VmlzdWFsR3JhZGllbnQoZGF0YSwgY29vcmRTeXMpIHx8IGRhdGEuZ2V0VmlzdWFsKCdjb2xvcicpO1xuICAgIHBvbHlsaW5lLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyggLy8gVXNlIGNvbG9yIGluIGxpbmVTdHlsZSBmaXJzdFxuICAgIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgICBmaWxsOiAnbm9uZScsXG4gICAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICB9KSk7XG4gICAgdmFyIHNtb290aCA9IHNlcmllc01vZGVsLmdldCgnc21vb3RoJyk7XG4gICAgc21vb3RoID0gZ2V0U21vb3RoKHNlcmllc01vZGVsLmdldCgnc21vb3RoJykpO1xuICAgIHBvbHlsaW5lLnNldFNoYXBlKHtcbiAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgc21vb3RoTW9ub3RvbmU6IHNlcmllc01vZGVsLmdldCgnc21vb3RoTW9ub3RvbmUnKSxcbiAgICAgIGNvbm5lY3ROdWxsczogc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKVxuICAgIH0pO1xuXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHZhciBzdGFja2VkT25TZXJpZXMgPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE9uU2VyaWVzJyk7XG4gICAgICB2YXIgc3RhY2tlZE9uU21vb3RoID0gMDtcbiAgICAgIHBvbHlnb24udXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpLCB7XG4gICAgICAgIGZpbGw6IHZpc3VhbENvbG9yLFxuICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChzdGFja2VkT25TZXJpZXMpIHtcbiAgICAgICAgc3RhY2tlZE9uU21vb3RoID0gZ2V0U21vb3RoKHN0YWNrZWRPblNlcmllcy5nZXQoJ3Ntb290aCcpKTtcbiAgICAgIH1cblxuICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgICBzdGFja2VkT25TbW9vdGg6IHN0YWNrZWRPblNtb290aCxcbiAgICAgICAgc21vb3RoTW9ub3RvbmU6IHNlcmllc01vZGVsLmdldCgnc21vb3RoTW9ub3RvbmUnKSxcbiAgICAgICAgY29ubmVjdE51bGxzOiBzZXJpZXNNb2RlbC5nZXQoJ2Nvbm5lY3ROdWxscycpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTsgLy8gU2F2ZSB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gZm9yIHRyYW5zaXRpb24gYW5pbWF0aW9uIHdoZW4gZGF0YSBjaGFuZ2VkXG5cbiAgICB0aGlzLl9jb29yZFN5cyA9IGNvb3JkU3lzO1xuICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cyA9IHN0YWNrZWRPblBvaW50cztcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5fdmFsdWVPcmlnaW4gPSB2YWx1ZU9yaWdpbjtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge30sXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuXG4gICAgaWYgKCEoZGF0YUluZGV4IGluc3RhbmNlb2YgQXJyYXkpICYmIGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG5cbiAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBzeW1ib2wgaWYgaXQgaXMgbm90IGV4aXN0c1xuICAgICAgICB2YXIgcHQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAoIXB0KSB7XG4gICAgICAgICAgLy8gTnVsbCBkYXRhXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbENseihkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgICBzeW1ib2wucG9zaXRpb24gPSBwdDtcbiAgICAgICAgc3ltYm9sLnNldFooc2VyaWVzTW9kZWwuZ2V0KCd6bGV2ZWwnKSwgc2VyaWVzTW9kZWwuZ2V0KCd6JykpO1xuICAgICAgICBzeW1ib2wuaWdub3JlID0gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbiAgICAgICAgc3ltYm9sLl9fdGVtcCA9IHRydWU7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIHN5bWJvbCk7IC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG5cbiAgICAgICAgc3ltYm9sLnN0b3BTeW1ib2xBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbC5oaWdobGlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGlnaGxpZ2h0IHdob2xlIHNlcmllc1xuICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQuY2FsbCh0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0sXG4gIGRvd25wbGF5OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwgJiYgZGF0YUluZGV4ID49IDApIHtcbiAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sLl9fdGVtcCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIG51bGwpO1xuICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHN5bWJvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ltYm9sLmRvd25wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIGNhbiBub3QgZG93bnBsYXkgY29tcGxldGVseS5cbiAgICAgIC8vIERvd25wbGF5IHdob2xlIHNlcmllc1xuICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5kb3ducGxheS5jYWxsKHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmV3UG9seWxpbmU6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgcG9seWxpbmVcblxuICAgIGlmIChwb2x5bGluZSkge1xuICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5bGluZSk7XG4gICAgfVxuXG4gICAgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0sXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMTBcbiAgICB9KTtcblxuICAgIHRoaXMuX2xpbmVHcm91cC5hZGQocG9seWxpbmUpO1xuXG4gICAgdGhpcy5fcG9seWxpbmUgPSBwb2x5bGluZTtcbiAgICByZXR1cm4gcG9seWxpbmU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHN0YWNrZWRPblBvaW50c1xuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25ld1BvbHlnb246IGZ1bmN0aW9uIChwb2ludHMsIHN0YWNrZWRPblBvaW50cykge1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgcG9seWdvblxuXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgfVxuXG4gICAgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgfSxcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5Z29uKTtcblxuICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLy8gRklYTUUgVHdvIHZhbHVlIGF4aXNcbiAgX3VwZGF0ZUFuaW1hdGlvbjogZnVuY3Rpb24gKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCwgdmFsdWVPcmlnaW4pIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGRpZmYgPSBsaW5lQW5pbWF0aW9uRGlmZih0aGlzLl9kYXRhLCBkYXRhLCB0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cywgdGhpcy5fY29vcmRTeXMsIGNvb3JkU3lzLCB0aGlzLl92YWx1ZU9yaWdpbiwgdmFsdWVPcmlnaW4pO1xuICAgIHZhciBjdXJyZW50ID0gZGlmZi5jdXJyZW50O1xuICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgIHZhciBzdGFja2VkT25OZXh0ID0gZGlmZi5zdGFja2VkT25OZXh0O1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICBzdGFja2VkT25DdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uQ3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgfSAvLyBgZGlmZi5jdXJyZW50YCBpcyBzdWJzZXQgb2YgYGN1cnJlbnRgICh3aGljaCBzaG91bGQgYmUgZW5zdXJlZCBieVxuICAgIC8vIHR1cm5Qb2ludHNJbnRvU3RlcCksIHNvIHBvaW50cyBpbiBgX19wb2ludHNgIGNhbiBiZSB1cGRhdGVkIHdoZW5cbiAgICAvLyBwb2ludHMgaW4gYGN1cnJlbnRgIGFyZSB1cGRhdGUgZHVyaW5nIGFuaW1hdGlvbi5cblxuXG4gICAgcG9seWxpbmUuc2hhcGUuX19wb2ludHMgPSBkaWZmLmN1cnJlbnQ7XG4gICAgcG9seWxpbmUuc2hhcGUucG9pbnRzID0gY3VycmVudDtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlsaW5lLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgIH1cbiAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICBpZiAocG9seWdvbikge1xuICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgIHBvaW50czogY3VycmVudCxcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25DdXJyZW50XG4gICAgICB9KTtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogbmV4dCxcbiAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbk5leHRcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVkRGF0YUluZm8gPSBbXTtcbiAgICB2YXIgZGlmZlN0YXR1cyA9IGRpZmYuc3RhdHVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmU3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY21kID0gZGlmZlN0YXR1c1tpXS5jbWQ7XG5cbiAgICAgIGlmIChjbWQgPT09ICc9Jykge1xuICAgICAgICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGlmZlN0YXR1c1tpXS5pZHgxKTtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB1cGRhdGVkRGF0YUluZm8ucHVzaCh7XG4gICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICBwdElkeDogaSAvLyBJbmRleCBvZiBwb2ludHNcblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvbHlsaW5lLmFuaW1hdG9ycyAmJiBwb2x5bGluZS5hbmltYXRvcnMubGVuZ3RoKSB7XG4gICAgICBwb2x5bGluZS5hbmltYXRvcnNbMF0uZHVyaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVkRGF0YUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWwgPSB1cGRhdGVkRGF0YUluZm9baV0uZWw7XG4gICAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2x5bGluZS5zaGFwZS5fX3BvaW50c1t1cGRhdGVkRGF0YUluZm9baV0ucHRJZHhdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICB0aGlzLl9zeW1ib2xEcmF3LnJlbW92ZSh0cnVlKTsgLy8gUmVtb3ZlIHRlbXBvcmFyeSBjcmVhdGVkIGVsZW1lbnRzIHdoZW4gaGlnaGxpZ2h0aW5nXG5cblxuICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9wb2x5bGluZSA9IHRoaXMuX3BvbHlnb24gPSB0aGlzLl9jb29yZFN5cyA9IHRoaXMuX3BvaW50cyA9IHRoaXMuX3N0YWNrZWRPblBvaW50cyA9IHRoaXMuX2RhdGEgPSBudWxsO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line/LineView.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/helper.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/helper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _dataStackHelper = __webpack_require__(/*! ../../data/helper/dataStackHelper */ \"./node_modules/echarts/lib/data/helper/dataStackHelper.js\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar map = _util.map;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (stacked |= isDimensionStacked(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    dims[0] = stackResultDim;\n  }\n\n  if (stacked |= isDimensionStacked(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9oZWxwZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9oZWxwZXIuanM/OWY4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxudmFyIF9kYXRhU3RhY2tIZWxwZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyXCIpO1xuXG52YXIgaXNEaW1lbnNpb25TdGFja2VkID0gX2RhdGFTdGFja0hlbHBlci5pc0RpbWVuc2lvblN0YWNrZWQ7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtYXAgPSBfdXRpbC5tYXA7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRTeXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVPcmlnaW4gbGluZVNlcmllcy5vcHRpb24uYXJlYVN0eWxlLm9yaWdpblxuICovXG5mdW5jdGlvbiBwcmVwYXJlRGF0YUNvb3JkSW5mbyhjb29yZFN5cywgZGF0YSwgdmFsdWVPcmlnaW4pIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gIHZhciB2YWx1ZVN0YXJ0ID0gZ2V0VmFsdWVTdGFydCh2YWx1ZUF4aXMsIHZhbHVlT3JpZ2luKTtcbiAgdmFyIGJhc2VBeGlzRGltID0gYmFzZUF4aXMuZGltO1xuICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzRGltKTtcbiAgdmFyIGJhc2VEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihiYXNlQXhpc0RpbSk7XG4gIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlQXhpc0RpbSA9PT0gJ3gnIHx8IHZhbHVlQXhpc0RpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcbiAgdmFyIGRpbXMgPSBtYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwRGltZW5zaW9uKGNvb3JkRGltKTtcbiAgfSk7XG4gIHZhciBzdGFja2VkO1xuICB2YXIgc3RhY2tSZXN1bHREaW0gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKTtcblxuICBpZiAoc3RhY2tlZCB8PSBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1swXVxuICAvKiwgZGltc1sxXSovXG4gICkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBkaW1zWzBdID0gc3RhY2tSZXN1bHREaW07XG4gIH1cblxuICBpZiAoc3RhY2tlZCB8PSBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1sxXVxuICAvKiwgZGltc1swXSovXG4gICkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBkaW1zWzFdID0gc3RhY2tSZXN1bHREaW07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGFEaW1zRm9yUG9pbnQ6IGRpbXMsXG4gICAgdmFsdWVTdGFydDogdmFsdWVTdGFydCxcbiAgICB2YWx1ZUF4aXNEaW06IHZhbHVlQXhpc0RpbSxcbiAgICBiYXNlQXhpc0RpbTogYmFzZUF4aXNEaW0sXG4gICAgc3RhY2tlZDogISFzdGFja2VkLFxuICAgIHZhbHVlRGltOiB2YWx1ZURpbSxcbiAgICBiYXNlRGltOiBiYXNlRGltLFxuICAgIGJhc2VEYXRhT2Zmc2V0OiBiYXNlRGF0YU9mZnNldCxcbiAgICBzdGFja2VkT3ZlckRpbWVuc2lvbjogZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRPdmVyRGltZW5zaW9uJylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVTdGFydCh2YWx1ZUF4aXMsIHZhbHVlT3JpZ2luKSB7XG4gIHZhciB2YWx1ZVN0YXJ0ID0gMDtcbiAgdmFyIGV4dGVudCA9IHZhbHVlQXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcblxuICBpZiAodmFsdWVPcmlnaW4gPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzBdO1xuICB9IGVsc2UgaWYgKHZhbHVlT3JpZ2luID09PSAnZW5kJykge1xuICAgIHZhbHVlU3RhcnQgPSBleHRlbnRbMV07XG4gIH0gLy8gYXV0b1xuICBlbHNlIHtcbiAgICAgIC8vIEJvdGggcG9zaXRpdmVcbiAgICAgIGlmIChleHRlbnRbMF0gPiAwKSB7XG4gICAgICAgIHZhbHVlU3RhcnQgPSBleHRlbnRbMF07XG4gICAgICB9IC8vIEJvdGggbmVnYXRpdmVcbiAgICAgIGVsc2UgaWYgKGV4dGVudFsxXSA8IDApIHtcbiAgICAgICAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzFdO1xuICAgICAgICB9IC8vIElmIGlzIG9uZSBwb3NpdGl2ZSwgYW5kIG9uZSBuZWdhdGl2ZSwgb25aZXJvIHNoYWxsIGJlIHRydWVcblxuICAgIH1cblxuICByZXR1cm4gdmFsdWVTdGFydDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tlZE9uUG9pbnQoZGF0YUNvb3JkSW5mbywgY29vcmRTeXMsIGRhdGEsIGlkeCkge1xuICB2YXIgdmFsdWUgPSBOYU47XG5cbiAgaWYgKGRhdGFDb29yZEluZm8uc3RhY2tlZCkge1xuICAgIHZhbHVlID0gZGF0YS5nZXQoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRPdmVyRGltZW5zaW9uJyksIGlkeCk7XG4gIH1cblxuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBkYXRhQ29vcmRJbmZvLnZhbHVlU3RhcnQ7XG4gIH1cblxuICB2YXIgYmFzZURhdGFPZmZzZXQgPSBkYXRhQ29vcmRJbmZvLmJhc2VEYXRhT2Zmc2V0O1xuICB2YXIgc3RhY2tlZERhdGEgPSBbXTtcbiAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoZGF0YUNvb3JkSW5mby5iYXNlRGltLCBpZHgpO1xuICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gdmFsdWU7XG4gIHJldHVybiBjb29yZFN5cy5kYXRhVG9Qb2ludChzdGFja2VkRGF0YSk7XG59XG5cbmV4cG9ydHMucHJlcGFyZURhdGFDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbztcbmV4cG9ydHMuZ2V0U3RhY2tlZE9uUG9pbnQgPSBnZXRTdGFja2VkT25Qb2ludDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line/helper.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/lineAnimationDiff.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _helper = __webpack_require__(/*! ./helper */ \"./node_modules/echarts/lib/chart/line/helper.js\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9saW5lQW5pbWF0aW9uRGlmZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzP2YxMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBfaGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgcHJlcGFyZURhdGFDb29yZEluZm8gPSBfaGVscGVyLnByZXBhcmVEYXRhQ29vcmRJbmZvO1xudmFyIGdldFN0YWNrZWRPblBvaW50ID0gX2hlbHBlci5nZXRTdGFja2VkT25Qb2ludDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gdmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ3pyZW5kZXIvc3JjL2NvcmUvYXJyYXlEaWZmJyk7XG4vLyAnenJlbmRlci9zcmMvY29yZS9hcnJheURpZmYnIGhhcyBiZWVuIHVzZWQgYmVmb3JlLCBidXQgaXQgZGlkXG4vLyBub3QgZG8gd2VsbCBpbiBwZXJmb3JtYW5jZSB3aGVuIHJvYW0gd2l0aCBmaXhlZCBkYXRhWm9vbSB3aW5kb3cuXG4vLyBmdW5jdGlvbiBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCkge1xuLy8gICAgIC8vIEdlbmVyYXRlIGludCBpZCBpbnN0ZWFkIG9mIHN0cmluZyBpZC5cbi8vICAgICAvLyBDb21wYXJlIHN0cmluZyBtYXliZSBzbG93IGluIHNjb3JlIGZ1bmN0aW9uIG9mIGFyckRpZmZcbi8vICAgICAvLyBBc3N1bWUgaWQgaW4gaWRMaXN0IGFyZSBhbGwgdW5pcXVlXG4vLyAgICAgdmFyIGlkSW5kaWNlc01hcCA9IHt9O1xuLy8gICAgIHZhciBpZHggPSAwO1xuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGlkSW5kaWNlc01hcFtuZXdJZExpc3RbaV1dID0gaWR4O1xuLy8gICAgICAgICBuZXdJZExpc3RbaV0gPSBpZHgrKztcbi8vICAgICB9XG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJZExpc3QubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgdmFyIG9sZElkID0gb2xkSWRMaXN0W2ldO1xuLy8gICAgICAgICAvLyBTYW1lIHdpdGggbmV3SWRMaXN0XG4vLyAgICAgICAgIGlmIChpZEluZGljZXNNYXBbb2xkSWRdKSB7XG4vLyAgICAgICAgICAgICBvbGRJZExpc3RbaV0gPSBpZEluZGljZXNNYXBbb2xkSWRdO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWR4Kys7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9XG5mdW5jdGlvbiBkaWZmRGF0YShvbGREYXRhLCBuZXdEYXRhKSB7XG4gIHZhciBkaWZmUmVzdWx0ID0gW107XG4gIG5ld0RhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgIGRpZmZSZXN1bHQucHVzaCh7XG4gICAgICBjbWQ6ICcrJyxcbiAgICAgIGlkeDogaWR4XG4gICAgfSk7XG4gIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICBkaWZmUmVzdWx0LnB1c2goe1xuICAgICAgY21kOiAnPScsXG4gICAgICBpZHg6IG9sZElkeCxcbiAgICAgIGlkeDE6IG5ld0lkeFxuICAgIH0pO1xuICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgIGRpZmZSZXN1bHQucHVzaCh7XG4gICAgICBjbWQ6ICctJyxcbiAgICAgIGlkeDogaWR4XG4gICAgfSk7XG4gIH0pLmV4ZWN1dGUoKTtcbiAgcmV0dXJuIGRpZmZSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG9sZERhdGEsIG5ld0RhdGEsIG9sZFN0YWNrZWRPblBvaW50cywgbmV3U3RhY2tlZE9uUG9pbnRzLCBvbGRDb29yZFN5cywgbmV3Q29vcmRTeXMsIG9sZFZhbHVlT3JpZ2luLCBuZXdWYWx1ZU9yaWdpbikge1xuICB2YXIgZGlmZiA9IGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpOyAvLyB2YXIgbmV3SWRMaXN0ID0gbmV3RGF0YS5tYXBBcnJheShuZXdEYXRhLmdldElkKTtcbiAgLy8gdmFyIG9sZElkTGlzdCA9IG9sZERhdGEubWFwQXJyYXkob2xkRGF0YS5nZXRJZCk7XG4gIC8vIGNvbnZlcnRUb0ludElkKG5ld0lkTGlzdCwgb2xkSWRMaXN0KTtcbiAgLy8gLy8gRklYTUUgT25lIGRhdGEgP1xuICAvLyBkaWZmID0gYXJyYXlEaWZmKG9sZElkTGlzdCwgbmV3SWRMaXN0KTtcblxuICB2YXIgY3VyclBvaW50cyA9IFtdO1xuICB2YXIgbmV4dFBvaW50cyA9IFtdOyAvLyBQb2ludHMgZm9yIHN0YWNraW5nIGJhc2UgbGluZVxuXG4gIHZhciBjdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgbmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIHN0YXR1cyA9IFtdO1xuICB2YXIgc29ydGVkSW5kaWNlcyA9IFtdO1xuICB2YXIgcmF3SW5kaWNlcyA9IFtdO1xuICB2YXIgbmV3RGF0YU9sZENvb3JkSW5mbyA9IHByZXBhcmVEYXRhQ29vcmRJbmZvKG9sZENvb3JkU3lzLCBuZXdEYXRhLCBvbGRWYWx1ZU9yaWdpbik7XG4gIHZhciBvbGREYXRhTmV3Q29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm8obmV3Q29vcmRTeXMsIG9sZERhdGEsIG5ld1ZhbHVlT3JpZ2luKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlmZkl0ZW0gPSBkaWZmW2ldO1xuICAgIHZhciBwb2ludEFkZGVkID0gdHJ1ZTsgLy8gRklYTUUsIGFuaW1hdGlvbiBpcyBub3Qgc28gcGVyZmVjdCB3aGVuIGRhdGFab29tIHdpbmRvdyBtb3ZlcyBmYXN0XG4gICAgLy8gV2hpY2ggaXMgaW4gY2FzZSByZW12b2luZyBvciBhZGQgbW9yZSB0aGFuIG9uZSBkYXRhIGluIHRoZSB0YWlsIG9yIGhlYWRcblxuICAgIHN3aXRjaCAoZGlmZkl0ZW0uY21kKSB7XG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIGN1cnJlbnRQdCA9IG9sZERhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgpO1xuICAgICAgICB2YXIgbmV4dFB0ID0gbmV3RGF0YS5nZXRJdGVtTGF5b3V0KGRpZmZJdGVtLmlkeDEpOyAvLyBJZiBwcmV2aW91cyBkYXRhIGlzIE5hTiwgdXNlIG5leHQgcG9pbnQgZGlyZWN0bHlcblxuICAgICAgICBpZiAoaXNOYU4oY3VycmVudFB0WzBdKSB8fCBpc05hTihjdXJyZW50UHRbMV0pKSB7XG4gICAgICAgICAgY3VycmVudFB0ID0gbmV4dFB0LnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyUG9pbnRzLnB1c2goY3VycmVudFB0KTtcbiAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5leHRQdCk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2RpZmZJdGVtLmlkeF0pO1xuICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHgxXSk7XG4gICAgICAgIHJhd0luZGljZXMucHVzaChuZXdEYXRhLmdldFJhd0luZGV4KGRpZmZJdGVtLmlkeDEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkQ29vcmRTeXMuZGF0YVRvUG9pbnQoW25ld0RhdGEuZ2V0KG5ld0RhdGFPbGRDb29yZEluZm8uZGF0YURpbXNGb3JQb2ludFswXSwgaWR4KSwgbmV3RGF0YS5nZXQobmV3RGF0YU9sZENvb3JkSW5mby5kYXRhRGltc0ZvclBvaW50WzFdLCBpZHgpXSkpO1xuICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3RGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkuc2xpY2UoKSk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2goZ2V0U3RhY2tlZE9uUG9pbnQobmV3RGF0YU9sZENvb3JkSW5mbywgb2xkQ29vcmRTeXMsIG5ld0RhdGEsIGlkeCkpO1xuICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tpZHhdKTtcbiAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICctJzpcbiAgICAgICAgdmFyIGlkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgdmFyIHJhd0luZGV4ID0gb2xkRGF0YS5nZXRSYXdJbmRleChpZHgpOyAvLyBEYXRhIGlzIHJlcGxhY2VkLiBJbiB0aGUgY2FzZSBvZiBkeW5hbWljIGRhdGEgcXVldWVcbiAgICAgICAgLy8gRklYTUUgRklYTUUgRklYTUVcblxuICAgICAgICBpZiAocmF3SW5kZXggIT09IGlkeCkge1xuICAgICAgICAgIGN1cnJQb2ludHMucHVzaChvbGREYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSk7XG4gICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0Nvb3JkU3lzLmRhdGFUb1BvaW50KFtvbGREYXRhLmdldChvbGREYXRhTmV3Q29vcmRJbmZvLmRhdGFEaW1zRm9yUG9pbnRbMF0sIGlkeCksIG9sZERhdGEuZ2V0KG9sZERhdGFOZXdDb29yZEluZm8uZGF0YURpbXNGb3JQb2ludFsxXSwgaWR4KV0pKTtcbiAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tpZHhdKTtcbiAgICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKGdldFN0YWNrZWRPblBvaW50KG9sZERhdGFOZXdDb29yZEluZm8sIG5ld0Nvb3JkU3lzLCBvbGREYXRhLCBpZHgpKTtcbiAgICAgICAgICByYXdJbmRpY2VzLnB1c2gocmF3SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50QWRkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfSAvLyBPcmlnaW5hbCBpbmRpY2VzXG5cblxuICAgIGlmIChwb2ludEFkZGVkKSB7XG4gICAgICBzdGF0dXMucHVzaChkaWZmSXRlbSk7XG4gICAgICBzb3J0ZWRJbmRpY2VzLnB1c2goc29ydGVkSW5kaWNlcy5sZW5ndGgpO1xuICAgIH1cbiAgfSAvLyBEaWZmIHJlc3VsdCBtYXkgYmUgY3Jvc3NlZCBpZiBhbGwgaXRlbXMgYXJlIGNoYW5nZWRcbiAgLy8gU29ydCBieSBkYXRhIGluZGV4XG5cblxuICBzb3J0ZWRJbmRpY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gcmF3SW5kaWNlc1thXSAtIHJhd0luZGljZXNbYl07XG4gIH0pO1xuICB2YXIgc29ydGVkQ3VyclBvaW50cyA9IFtdO1xuICB2YXIgc29ydGVkTmV4dFBvaW50cyA9IFtdO1xuICB2YXIgc29ydGVkQ3VyclN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIHNvcnRlZE5leHRTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWRTdGF0dXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZEluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWR4ID0gc29ydGVkSW5kaWNlc1tpXTtcbiAgICBzb3J0ZWRDdXJyUG9pbnRzW2ldID0gY3VyclBvaW50c1tpZHhdO1xuICAgIHNvcnRlZE5leHRQb2ludHNbaV0gPSBuZXh0UG9pbnRzW2lkeF07XG4gICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaV0gPSBjdXJyU3RhY2tlZFBvaW50c1tpZHhdO1xuICAgIHNvcnRlZE5leHRTdGFja2VkUG9pbnRzW2ldID0gbmV4dFN0YWNrZWRQb2ludHNbaWR4XTtcbiAgICBzb3J0ZWRTdGF0dXNbaV0gPSBzdGF0dXNbaWR4XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3VycmVudDogc29ydGVkQ3VyclBvaW50cyxcbiAgICBuZXh0OiBzb3J0ZWROZXh0UG9pbnRzLFxuICAgIHN0YWNrZWRPbkN1cnJlbnQ6IHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzLFxuICAgIHN0YWNrZWRPbk5leHQ6IHNvcnRlZE5leHRTdGFja2VkUG9pbnRzLFxuICAgIHN0YXR1czogc29ydGVkU3RhdHVzXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/poly.js":
/*!*****************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/poly.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Path = __webpack_require__(/*! zrender/lib/graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar vec2 = __webpack_require__(/*! zrender/lib/core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar fixClipWithShadow = __webpack_require__(/*! zrender/lib/graphic/helper/fixClipWithShadow */ \"./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9wb2x5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcz9kNGQxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgZml4Q2xpcFdpdGhTaGFkb3cgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIFBvbHkgcGF0aCBzdXBwb3J0IE5hTiBwb2ludFxudmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbnZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG52YXIgc2NhbGVBbmRBZGQgPSB2ZWMyLnNjYWxlQW5kQWRkO1xudmFyIHYyQ29weSA9IHZlYzIuY29weTsgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlXG5cbnZhciB2ID0gW107XG52YXIgY3AwID0gW107XG52YXIgY3AxID0gW107XG5cbmZ1bmN0aW9uIGlzUG9pbnROdWxsKHApIHtcbiAgcmV0dXJuIGlzTmFOKHBbMF0pIHx8IGlzTmFOKHBbMV0pO1xufVxuXG5mdW5jdGlvbiBkcmF3U2VnbWVudChjdHgsIHBvaW50cywgc3RhcnQsIHNlZ0xlbiwgYWxsTGVuLCBkaXIsIHNtb290aE1pbiwgc21vb3RoTWF4LCBzbW9vdGgsIHNtb290aE1vbm90b25lLCBjb25uZWN0TnVsbHMpIHtcbiAgLy8gaWYgKHNtb290aE1vbm90b25lID09IG51bGwpIHtcbiAgLy8gICAgIGlmIChpc01vbm8ocG9pbnRzLCAneCcpKSB7XG4gIC8vICAgICAgICAgcmV0dXJuIGRyYXdNb25vKGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sXG4gIC8vICAgICAgICAgICAgIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgJ3gnLCBjb25uZWN0TnVsbHMpO1xuICAvLyAgICAgfVxuICAvLyAgICAgZWxzZSBpZiAoaXNNb25vKHBvaW50cywgJ3knKSkge1xuICAvLyAgICAgICAgIHJldHVybiBkcmF3TW9ubyhjdHgsIHBvaW50cywgc3RhcnQsIHNlZ0xlbiwgYWxsTGVuLFxuICAvLyAgICAgICAgICAgICBkaXIsIHNtb290aE1pbiwgc21vb3RoTWF4LCBzbW9vdGgsICd5JywgY29ubmVjdE51bGxzKTtcbiAgLy8gICAgIH1cbiAgLy8gICAgIGVsc2Uge1xuICAvLyAgICAgICAgIHJldHVybiBkcmF3Tm9uTW9uby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAvLyAgICAgfVxuICAvLyB9XG4gIC8vIGVsc2UgaWYgKHNtb290aE1vbm90b25lICE9PSAnbm9uZScgJiYgaXNNb25vKHBvaW50cywgc21vb3RoTW9ub3RvbmUpKSB7XG4gIC8vICAgICByZXR1cm4gZHJhd01vbm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgLy8gfVxuICAvLyBlbHNlIHtcbiAgLy8gICAgIHJldHVybiBkcmF3Tm9uTW9uby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAvLyB9XG4gIGlmIChzbW9vdGhNb25vdG9uZSA9PT0gJ25vbmUnIHx8ICFzbW9vdGhNb25vdG9uZSkge1xuICAgIHJldHVybiBkcmF3Tm9uTW9uby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkcmF3TW9uby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG4vKipcbiAqIENoZWNrIGlmIHBvaW50cyBpcyBpbiBtb25vdG9uZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdW119IHBvaW50cyAgICAgICAgIEFycmF5IG9mIHBvaW50cyB3aGljaCBpcyBpbiBbeCwgeV0gZm9ybVxuICogQHBhcmFtIHtzdHJpbmd9ICAgICBzbW9vdGhNb25vdG9uZSAneCcsICd5Jywgb3IgJ25vbmUnLCBzdGF0aW5nIGZvciB3aGljaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb24gdGhhdCBpcyBjaGVja2luZy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgaXMgJ25vbmUnLCBgZHJhd05vbk1vbm9gIHNob3VsZCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGlzIHVuZGVmaW5lZCwgZWl0aGVyIGJlaW5nIG1vbm90b25lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluICd4JyBvciAneScgd2lsbCBjYWxsIGBkcmF3TW9ub2AuXG4gKi9cbi8vIGZ1bmN0aW9uIGlzTW9ubyhwb2ludHMsIHNtb290aE1vbm90b25lKSB7XG4vLyAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSkge1xuLy8gICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICB9XG4vLyAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbi8vICAgICB2YXIgbGFzdCA9IHBvaW50c1swXVtkaW1dO1xuLy8gICAgIHZhciBsYXN0RGlmZiA9IDA7XG4vLyAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbi8vICAgICAgICAgdmFyIGRpZmYgPSBwb2ludHNbaV1bZGltXSAtIGxhc3Q7XG4vLyAgICAgICAgIGlmICghaXNOYU4oZGlmZikgJiYgIWlzTmFOKGxhc3REaWZmKVxuLy8gICAgICAgICAgICAgJiYgZGlmZiAhPT0gMCAmJiBsYXN0RGlmZiAhPT0gMFxuLy8gICAgICAgICAgICAgJiYgKChkaWZmID49IDApICE9PSAobGFzdERpZmYgPj0gMCkpXG4vLyAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGlmICghaXNOYU4oZGlmZikgJiYgZGlmZiAhPT0gMCkge1xuLy8gICAgICAgICAgICAgbGFzdERpZmYgPSBkaWZmO1xuLy8gICAgICAgICAgICAgbGFzdCA9IHBvaW50c1tpXVtkaW1dO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiB0cnVlO1xuLy8gfVxuXG4vKipcbiAqIERyYXcgc21vb3RoZWQgbGluZSBpbiBtb25vdG9uZSwgaW4gd2hpY2ggb25seSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGJlemllclxuICogY29udHJvbCBwb2ludHMgd2lsbCBiZSB1c2VkLiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gcG9pbnRzIGFyZSBtb25vdG9uZVxuICogZWl0aGVyIGluIHggb3IgeSBkaW1lbnNpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBkcmF3TW9ubyhjdHgsIHBvaW50cywgc3RhcnQsIHNlZ0xlbiwgYWxsTGVuLCBkaXIsIHNtb290aE1pbiwgc21vb3RoTWF4LCBzbW9vdGgsIHNtb290aE1vbm90b25lLCBjb25uZWN0TnVsbHMpIHtcbiAgdmFyIHByZXZJZHggPSAwO1xuICB2YXIgaWR4ID0gc3RhcnQ7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWdMZW47IGsrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2lkeF07XG5cbiAgICBpZiAoaWR4ID49IGFsbExlbiB8fCBpZHggPCAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaXNQb2ludE51bGwocCkpIHtcbiAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpZHggPT09IHN0YXJ0KSB7XG4gICAgICBjdHhbZGlyID4gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHBbMF0sIHBbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgIHZhciBkaW0gPSBzbW9vdGhNb25vdG9uZSA9PT0gJ3knID8gMSA6IDA7IC8vIExlbmd0aCBvZiBjb250cm9sIHBvaW50IHRvIHAsIGVpdGhlciBpbiB4IG9yIHksIGJ1dCBub3QgYm90aFxuXG4gICAgICAgIHZhciBjdHJsTGVuID0gKHBbZGltXSAtIHByZXZQW2RpbV0pICogc21vb3RoO1xuICAgICAgICB2MkNvcHkoY3AwLCBwcmV2UCk7XG4gICAgICAgIGNwMFtkaW1dID0gcHJldlBbZGltXSArIGN0cmxMZW47XG4gICAgICAgIHYyQ29weShjcDEsIHApO1xuICAgICAgICBjcDFbZGltXSA9IHBbZGltXSAtIGN0cmxMZW47XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMFswXSwgY3AwWzFdLCBjcDFbMF0sIGNwMVsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZJZHggPSBpZHg7XG4gICAgaWR4ICs9IGRpcjtcbiAgfVxuXG4gIHJldHVybiBrO1xufVxuLyoqXG4gKiBEcmF3IHNtb290aGVkIGxpbmUgaW4gbm9uLW1vbm90b25lLCBpbiBtYXkgY2F1c2UgdW5kZXNpcmVkIGN1cnZlIGluIGV4dHJlbWVcbiAqIHNpdHVhdGlvbnMuIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBwb2ludHMgYXJlIG5vbi1tb25vdG9uZSBuZWl0aGVyIGluIHggb3JcbiAqIHkgZGltZW5zaW9uLlxuICovXG5cblxuZnVuY3Rpb24gZHJhd05vbk1vbm8oY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbiwgZGlyLCBzbW9vdGhNaW4sIHNtb290aE1heCwgc21vb3RoLCBzbW9vdGhNb25vdG9uZSwgY29ubmVjdE51bGxzKSB7XG4gIHZhciBwcmV2SWR4ID0gMDtcbiAgdmFyIGlkeCA9IHN0YXJ0O1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc2VnTGVuOyBrKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpZHhdO1xuXG4gICAgaWYgKGlkeCA+PSBhbGxMZW4gfHwgaWR4IDwgMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzUG9pbnROdWxsKHApKSB7XG4gICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgY3R4W2RpciA+IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShwWzBdLCBwWzFdKTtcbiAgICAgIHYyQ29weShjcDAsIHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuXG4gICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICB3aGlsZSAobmV4dFAgJiYgaXNQb2ludE51bGwocG9pbnRzW25leHRJZHhdKSkge1xuICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTsgLy8gTGFzdCBwb2ludFxuXG4gICAgICAgIGlmICghbmV4dFAgfHwgaXNQb2ludE51bGwobmV4dFApKSB7XG4gICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbmV4dCBkYXRhIGlzIG51bGwgaW4gbm90IGNvbm5lY3QgY2FzZVxuICAgICAgICAgIGlmIChpc1BvaW50TnVsbChuZXh0UCkgJiYgIWNvbm5lY3ROdWxscykge1xuICAgICAgICAgICAgbmV4dFAgPSBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG4gICAgICAgICAgdmFyIGxlblByZXZTZWc7XG4gICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG5cbiAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gc21vb3RoTW9ub3RvbmUgPT09ICd4JyA/IDAgOiAxO1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IE1hdGguYWJzKHBbZGltXSAtIHByZXZQW2RpbV0pO1xuICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5QcmV2U2VnID0gdmVjMi5kaXN0KHAsIHByZXZQKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSB2ZWMyLmRpc3QocCwgbmV4dFApO1xuICAgICAgICAgIH0gLy8gVXNlIHJhdGlvIG9mIHNlZyBsZW5ndGhcblxuXG4gICAgICAgICAgcmF0aW9OZXh0U2VnID0gbGVuTmV4dFNlZyAvIChsZW5OZXh0U2VnICsgbGVuUHJldlNlZyk7XG4gICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgfSAvLyBTbW9vdGggY29uc3RyYWludFxuXG5cbiAgICAgICAgdmVjMk1pbihjcDAsIGNwMCwgc21vb3RoTWF4KTtcbiAgICAgICAgdmVjMk1heChjcDAsIGNwMCwgc21vb3RoTWluKTtcbiAgICAgICAgdmVjMk1pbihjcDEsIGNwMSwgc21vb3RoTWF4KTtcbiAgICAgICAgdmVjMk1heChjcDEsIGNwMSwgc21vb3RoTWluKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AwWzBdLCBjcDBbMV0sIGNwMVswXSwgY3AxWzFdLCBwWzBdLCBwWzFdKTsgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuXG4gICAgICAgIHNjYWxlQW5kQWRkKGNwMCwgcCwgdiwgc21vb3RoICogcmF0aW9OZXh0U2VnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldklkeCA9IGlkeDtcbiAgICBpZHggKz0gZGlyO1xuICB9XG5cbiAgcmV0dXJuIGs7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHBvaW50cywgc21vb3RoQ29uc3RyYWludCkge1xuICB2YXIgcHRNaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgdmFyIHB0TWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICBpZiAoc21vb3RoQ29uc3RyYWludCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICAgIGlmIChwdFswXSA8IHB0TWluWzBdKSB7XG4gICAgICAgIHB0TWluWzBdID0gcHRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFsxXSA8IHB0TWluWzFdKSB7XG4gICAgICAgIHB0TWluWzFdID0gcHRbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7XG4gICAgICAgIHB0TWF4WzBdID0gcHRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFsxXSA+IHB0TWF4WzFdKSB7XG4gICAgICAgIHB0TWF4WzFdID0gcHRbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IHNtb290aENvbnN0cmFpbnQgPyBwdE1pbiA6IHB0TWF4LFxuICAgIG1heDogc21vb3RoQ29uc3RyYWludCA/IHB0TWF4IDogcHRNaW5cbiAgfTtcbn1cblxudmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnZWMtcG9seWxpbmUnLFxuICBzaGFwZToge1xuICAgIHBvaW50czogW10sXG4gICAgc21vb3RoOiAwLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IHRydWUsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIGZpbGw6IG51bGwsXG4gICAgc3Ryb2tlOiAnIzAwMCdcbiAgfSxcbiAgYnJ1c2g6IGZpeENsaXBXaXRoU2hhZG93KFBhdGgucHJvdG90eXBlLmJydXNoKSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuIC0gMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tpXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpICs9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgcmVzdWx0Lm1pbiwgcmVzdWx0Lm1heCwgc2hhcGUuc21vb3RoLCBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzKSArIDE7XG4gICAgfVxuICB9XG59KTtcbnZhciBQb2x5Z29uID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnZWMtcG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBbXSxcbiAgICAvLyBPZmZzZXQgYmV0d2VlbiBzdGFja2VkIGJhc2UgcG9pbnRzIGFuZCBwb2ludHNcbiAgICBzdGFja2VkT25Qb2ludHM6IFtdLFxuICAgIHNtb290aDogMCxcbiAgICBzdGFja2VkT25TbW9vdGg6IDAsXG4gICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcbiAgICBzbW9vdGhNb25vdG9uZTogbnVsbCxcbiAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBzaGFwZS5zdGFja2VkT25Qb2ludHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAvLyBNdXN0IHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBudWxsIHZhbHVlcyBhdm9pZCBkcmF3IGVycm9yIGluIHBvbHlnb25cbiAgICAgIGZvciAoOyBsZW4gPiAwOyBsZW4tLSkge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tsZW4gLSAxXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIGksIGxlbiwgbGVuLCAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBkcmF3U2VnbWVudChjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sIC0xLCBzdGFja2VkT25CQm94Lm1pbiwgc3RhY2tlZE9uQkJveC5tYXgsIHNoYXBlLnN0YWNrZWRPblNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBpICs9IGsgKyAxO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxufSk7XG5leHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/chart/line/poly.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/component/grid.js":
/*!****************************************************!*\
  !*** ./node_modules/echarts/lib/component/grid.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n__webpack_require__(/*! ./gridSimple */ \"./node_modules/echarts/lib/component/gridSimple.js\");\n\n__webpack_require__(/*! ./axisPointer/CartesianAxisPointer */ \"./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\");\n\n__webpack_require__(/*! ./axisPointer */ \"./node_modules/echarts/lib/component/axisPointer.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWQuanM/Y2QxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxucmVxdWlyZShcIi4vZ3JpZFNpbXBsZVwiKTtcblxucmVxdWlyZShcIi4vYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXJcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXNQb2ludGVyXCIpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/component/grid.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/layout/points.js":
/*!***************************************************!*\
  !*** ./node_modules/echarts/lib/layout/points.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = __webpack_require__(/*! zrender/lib/core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(/*! ../chart/helper/createRenderPlanner */ \"./node_modules/echarts/lib/chart/helper/createRenderPlanner.js\");\n\nvar _dataStackHelper = __webpack_require__(/*! ../data/helper/dataStackHelper */ \"./node_modules/echarts/lib/data/helper/dataStackHelper.js\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzPzg3YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtYXAgPSBfdXRpbC5tYXA7XG5cbnZhciBjcmVhdGVSZW5kZXJQbGFubmVyID0gcmVxdWlyZShcIi4uL2NoYXJ0L2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyXCIpO1xuXG52YXIgX2RhdGFTdGFja0hlbHBlciA9IHJlcXVpcmUoXCIuLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXJcIik7XG5cbnZhciBpc0RpbWVuc2lvblN0YWNrZWQgPSBfZGF0YVN0YWNrSGVscGVyLmlzRGltZW5zaW9uU3RhY2tlZDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICAgIHZhciBpc0xhcmdlUmVuZGVyID0gcGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuXG4gICAgICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbXMgPSBtYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4gZGF0YS5tYXBEaW1lbnNpb24oZGltKTtcbiAgICAgIH0pLnNsaWNlKDAsIDIpO1xuICAgICAgdmFyIGRpbUxlbiA9IGRpbXMubGVuZ3RoO1xuICAgICAgdmFyIHN0YWNrUmVzdWx0RGltID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJyk7XG5cbiAgICAgIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1swXVxuICAgICAgLyosIGRpbXNbMV0qL1xuICAgICAgKSkge1xuICAgICAgICBkaW1zWzBdID0gc3RhY2tSZXN1bHREaW07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1sxXVxuICAgICAgLyosIGRpbXNbMF0qL1xuICAgICAgKSkge1xuICAgICAgICBkaW1zWzFdID0gc3RhY2tSZXN1bHREaW07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKHBhcmFtcywgZGF0YSkge1xuICAgICAgICB2YXIgc2VnQ291bnQgPSBwYXJhbXMuZW5kIC0gcGFyYW1zLnN0YXJ0O1xuICAgICAgICB2YXIgcG9pbnRzID0gaXNMYXJnZVJlbmRlciAmJiBuZXcgRmxvYXQzMkFycmF5KHNlZ0NvdW50ICogZGltTGVuKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0LCBvZmZzZXQgPSAwLCB0bXBJbiA9IFtdLCB0bXBPdXQgPSBbXTsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgIHZhciBwb2ludDtcblxuICAgICAgICAgIGlmIChkaW1MZW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaSk7XG4gICAgICAgICAgICBwb2ludCA9ICFpc05hTih4KSAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCh4LCBudWxsLCB0bXBPdXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRtcEluWzBdID0gZGF0YS5nZXQoZGltc1swXSwgaSk7XG4gICAgICAgICAgICB2YXIgeSA9IHRtcEluWzFdID0gZGF0YS5nZXQoZGltc1sxXSwgaSk7IC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG5cbiAgICAgICAgICAgIHBvaW50ID0gIWlzTmFOKHgpICYmICFpc05hTih5KSAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCh0bXBJbiwgbnVsbCwgdG1wT3V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNMYXJnZVJlbmRlcikge1xuICAgICAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHBvaW50ID8gcG9pbnRbMF0gOiBOYU47XG4gICAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnQgPyBwb2ludFsxXSA6IE5hTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGksIHBvaW50ICYmIHBvaW50LnNsaWNlKCkgfHwgW05hTiwgTmFOXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNMYXJnZVJlbmRlciAmJiBkYXRhLnNldExheW91dCgnc3ltYm9sUG9pbnRzJywgcG9pbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbUxlbiAmJiB7XG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/layout/points.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataSample.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/processor/dataSample.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTYW1wbGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTYW1wbGUuanM/ZmRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIHNhbXBsZXJzID0ge1xuICBhdmVyYWdlOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc05hTihmcmFtZVtpXSkpIHtcbiAgICAgICAgc3VtICs9IGZyYW1lW2ldO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIE5hTiBpZiBjb3VudCBpcyAwXG5cblxuICAgIHJldHVybiBjb3VudCA9PT0gMCA/IE5hTiA6IHN1bSAvIGNvdW50O1xuICB9LFxuICBzdW06IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gSWdub3JlIE5hTlxuICAgICAgc3VtICs9IGZyYW1lW2ldIHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhbWVbaV0gPiBtYXggJiYgKG1heCA9IGZyYW1lW2ldKTtcbiAgICB9IC8vIE5hTiB3aWxsIGNhdXNlIGlsbGVnYWwgYXhpcyBleHRlbnQuXG5cblxuICAgIHJldHVybiBpc0Zpbml0ZShtYXgpID8gbWF4IDogTmFOO1xuICB9LFxuICBtaW46IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldIDwgbWluICYmIChtaW4gPSBmcmFtZVtpXSk7XG4gICAgfSAvLyBOYU4gd2lsbCBjYXVzZSBpbGxlZ2FsIGF4aXMgZXh0ZW50LlxuXG5cbiAgICByZXR1cm4gaXNGaW5pdGUobWluKSA/IG1pbiA6IE5hTjtcbiAgfSxcbiAgLy8gVE9ET1xuICAvLyBNZWRpYW5cbiAgbmVhcmVzdDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcmV0dXJuIGZyYW1lWzBdO1xuICB9XG59O1xuXG52YXIgaW5kZXhTYW1wbGVyID0gZnVuY3Rpb24gKGZyYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChmcmFtZS5sZW5ndGggLyAyKTtcbn07XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlLFxuICAgIG1vZGlmeU91dHB1dEVuZDogdHJ1ZSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHNhbXBsaW5nID0gc2VyaWVzTW9kZWwuZ2V0KCdzYW1wbGluZycpO1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmdcblxuICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgc2FtcGxpbmcpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTsgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuXG4gICAgICAgIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZSk7XG5cbiAgICAgICAgaWYgKHJhdGUgPiAxKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZXI7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsZXJzW3NhbXBsaW5nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgc2FtcGxlIHRoZSBmaXJzdCBkaW0gbWFwcGVkIGZyb20gdmFsdWUgYXhpcy5cbiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YS5kb3duU2FtcGxlKGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pLCAxIC8gcmF0ZSwgc2FtcGxlciwgaW5kZXhTYW1wbGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/processor/dataSample.js\n");

/***/ }),

/***/ "./node_modules/echarts/lib/visual/symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/echarts/lib/visual/symbol.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzPzdmOTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUsIGRlZmF1bHRTeW1ib2xUeXBlLCBsZWdlbmRTeW1ib2wpIHtcbiAgLy8gRW5jb2RpbmcgdmlzdWFsIGZvciBhbGwgc2VyaWVzIGluY2x1ZGUgd2hpY2ggaXMgZmlsdGVyZWQgZm9yIGxlZ2VuZCBkcmF3aW5nXG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICAvLyBGb3IgbGVnZW5kLlxuICAgIHBlcmZvcm1SYXdTZXJpZXM6IHRydWUsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIHZhciBzeW1ib2xUeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2wnKSB8fCBkZWZhdWx0U3ltYm9sVHlwZTtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG4gICAgICB2YXIga2VlcEFzcGVjdCA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sS2VlcEFzcGVjdCcpO1xuICAgICAgZGF0YS5zZXRWaXN1YWwoe1xuICAgICAgICBsZWdlbmRTeW1ib2w6IGxlZ2VuZFN5bWJvbCB8fCBzeW1ib2xUeXBlLFxuICAgICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICAgIHN5bWJvbFNpemU6IHN5bWJvbFNpemUsXG4gICAgICAgIHN5bWJvbEtlZXBBc3BlY3Q6IGtlZXBBc3BlY3RcbiAgICAgIH0pOyAvLyBPbmx5IHZpc2libGUgc2VyaWVzIGhhcyBlYWNoIGRhdGEgYmUgdmlzdWFsIGVuY29kZWRcblxuICAgICAgaWYgKGVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSB0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgZnVuY3Rpb24gZGF0YUVhY2goZGF0YSwgaWR4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciByYXdWYWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7IC8vIEZJWE1FXG5cbiAgICAgICAgICB2YXIgcGFyYW1zID0gc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcyhpZHgpO1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJywgc3ltYm9sU2l6ZShyYXdWYWx1ZSwgcGFyYW1zKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgdmFyIGl0ZW1TeW1ib2xUeXBlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcsIHRydWUpO1xuICAgICAgICAgIHZhciBpdGVtU3ltYm9sU2l6ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xTaXplJywgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGl0ZW1TeW1ib2xLZWVwQXNwZWN0ID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbEtlZXBBc3BlY3QnLCB0cnVlKTsgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG5cbiAgICAgICAgICBpZiAoaXRlbVN5bWJvbFR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcsIGl0ZW1TeW1ib2xUeXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXRlbVN5bWJvbFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUEVORElORyBUcmFuc2Zvcm0gc3ltYm9sU2l6ZSA/XG4gICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIGl0ZW1TeW1ib2xTaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXRlbVN5bWJvbEtlZXBBc3BlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbEtlZXBBc3BlY3QnLCBpdGVtU3ltYm9sS2VlcEFzcGVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFFYWNoOiBkYXRhLmhhc0l0ZW1PcHRpb24gfHwgaGFzQ2FsbGJhY2sgPyBkYXRhRWFjaCA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts/lib/visual/symbol.js\n");

/***/ })

}]);